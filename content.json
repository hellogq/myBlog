[{"title":"微信小程序入坑-事件","date":"2017-02-27T11:48:42.000Z","path":"2017/02/27/微信小程序入坑-事件/","text":"今天在看微信小程序的案例时看到了一个这样的”句子”e.currentTarget.dataset.nav,当时有点懵,这是个啥?然后查了一下API,问了一下度娘,原来是个啥……要想明白e.currentTarget.dataset.nav就得先明白什么是事件(以下是从微信小程序文档上扒下来的). 事件什么是事件 事件是视图层到逻辑层的通讯方式. 事件可以将用户的行为反馈到逻辑层进行处理. 事件可以绑定在组件上,当达到触发事件,就会执行逻辑层中对应的事件处理函数. 事件对象可以携带额外信息,如id,dataset,touches. 事件的使用方式 在组件中绑定一个事件处理函数 如bindtap,当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数.&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt;Click me!&lt;/view&gt; 在相应的Page定义中写上相应的事件处理函数,参数是event. 12345Page(&#123; tapName:function(event)&#123; console.log(event) &#125;&#125;) 可以看出log出来的信息大致如下: 说完什么是事件,那么事件有事件对象,而让我懵掉的就是这个事件对象中的东西 事件对象如没有特殊说明,当组件触发事件时,逻辑层绑定该事件的处理函数就会收到一个事件对象. BaseEvent基础事件对象属性列表:到了这里又不得不说一下target与currentTaget的区别了(这个就写在下一章吧……看着有点乱) CustomEvent自定义事件对象属性列表(继承BaseEvent): type 代表事件的类型 timeStamp 页面打开到触发事件所经过的毫秒数. target 触发事件的原组件 currentTarget 事件绑定的当前组件 dataset在组件中可以定义数据,这些数据将会通过事件传递给SERVICE.书写方式:以data-开头,对个单词由连字符-链接,不能由大写(大写会自动转成小写)例如:data-element-type,最终在event.target.dataset中会将连字符转成驼峰elementTyoe. 举个栗子1&lt;view data-alpha-beta=&quot;1&quot; data-alphaBeta=&quot;2&quot; bindtap=&quot;bindName&quot;&gt;DataSet Test&lt;/view&gt; 123456Page(&#123; bindName:function(e)&#123; e.target.dataset.alphaBeta ===1 //-会转为驼峰写法 e.target.dataset.alphabeta ===2 //大写会转为小写 &#125; &#125;) 感觉有点扯远了……回归正题…e.currentTarget.dataset.nav到底是个啥呢?就是当前绑定事件的这个元素的data-nav的值1&lt;view data-nav = &quot;1&quot; bindtap=&quot;getclick&quot;&gt;Click Me&lt;/view&gt; 1234getclick:function(e)&#123; // 结果是1 console.log(e.currentTarget.dataset.nav);&#125;","tags":[]},{"title":"","date":"2017-01-17T05:57:26.613Z","path":"2017/01/17/hybrid/","text":"混合app开发 混合app开发介绍 application（应用） 用前端的知识（html,css,js）开发出来手机App的方式就叫做混合App开发 App开发的三种类型 WebApp:跑在手机浏览器中运行的web应用（微信公众号，微信小程序） NativeApp:用android和Object-C等原生语言开发的应用 HybridApp:就是在Html5网站外面加了一个原生的容器，兼具2者的优势 App开发三种方式原理对比图 三种App开发优缺点对比图 企业如何选择用那种方式开发产品那？ 企业要根据自身的特点进行app开发方式的选择，不要为了混合而混合 混合app开发方式不是银弹,混合app更适合为初创型公司快速占领市场，还有业务型的app更适合用 混合app的开发方式是未来的主流趋势。 原生混合html页面 html页面加原生容器的壳子 App开发的一些常见平台混合App的Ionic Ionic官网 http://ionicframework.com/ Ionic中文网 http://www.ionic.wang/ Html5+ 官网http://www.dcloud.io/ AppCan 官网地址:http://www.appcan.cn/ 原生App的ReactNative RN官网https://facebook.github.io/react-native/ RN中文网http://react-native.cn/ weex weex官网http://alibaba.github.io/weex/ webApp的微信公众号 https://my.oschina.net/u/1416844/blog/796475 https://my.oschina.net/u/1416844/blog/796470 https://my.oschina.net/u/1416844/blog/796474 微信小程序 https://my.oschina.net/u/1416844/blog/759209 混合app环境安装注意 所有的开发环境都安装在c盘 所有目录不要出现中文 系统环境安装 java环境配置 在百度上搜索“java jdk下载”并安装 配置到全局变量JAVA_HOME中http://jingyan.baidu.com/article/f96699bb8b38e0894e3c1bef.html Node环境配置 node要下载最新的LTS（长期支持版本）版本 npm升级到最新版本 npm install npm@latest -g c++环境配置 最好是用vs去安装c++环境 git环境配置 在百度搜”git下载”，并安装 配置到全局变量http://jingyan.baidu.com/article/9f7e7ec0b17cac6f2815548d.html Python环境配置 在百度搜”python下载”，并安装 配置到全局变量http://jingyan.baidu.com/article/48206aeafdcf2a216ad6b316.html android环境配置Android ADT（android develop tools）安装 android的环境配置有很多种方式，我们选择的是手动安装方式 Android Studio Eclipse 手动安装 从http://www.androiddevtools.cn/下载android所需要的包 点击installer_r24.3.4-windows进行安装，其他文件只需要解压缩后，放置结构如下图即可。Android项目结构 build-toos有些特殊，文件夹必须是版本号 Android-sdkPlatform-toolsToolsBuild-toolsextras一共有6个东西需要安装 Android环境变量配置 ANDROID_HOME：C:\\Program Files\\android（有tools文件夹的根目录） path：%ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools 在命令窗口输入adb进行检测 混合app快速开始下载项目并打包","tags":[]},{"title":"如何实现浏览器内多个标签页之间的通信","date":"2016-12-29T13:35:53.000Z","path":"2016/12/29/实现浏览器内多个标签页之间的通信/","text":"调用localStorage,cookies等本地存储的方式方法一:使用localStorage使用localStorage.setItem(key,value);添加调用的内容使用storage事件监听添加/删除/修改的动作123window.addEventListener(\"storage\",function(event)&#123; $(\"#name\").val(event.key +\"=\"+ event.newValue); &#125;) 方法二:使用cookie+setInterval12&lt;input type=\"text\" id=\"name\"&gt;&lt;input type=\"button\" id=\"btn\" value=\"发送\"&gt; 1234567891011121314$(function()&#123; $(\"#btn\").click(function()&#123; var name = $(\"#name\").val; document.cookie = \"name = \"+name; &#125;) &#125;); //获取cookie中的内容 function getKey(key)&#123; return JSON.parse(\"&#123;\\\"\"+ document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") +\"\\\"&#125;\")[key] &#125; //每隔1秒获取cookie的内容 setInterval(function()&#123; console.log(getKey(\"name\")); &#125;,1000);","tags":[]},{"title":"Canvas 高级篇","date":"2016-12-19T14:42:22.000Z","path":"2016/12/19/Canvas 高级篇/","text":"3. 高级篇3.1. 变换Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有1.CanvasRenderingContext2D.transform()2.CanvasRenderingContext2D.scale()3.CanvasRenderingContext2D.translate()4.CanvasRenderingContext2D.rotate()5.CanvasRenderingContext2D.setTransForm()还有一些方法, 暂时没有普及与确定. 因此这里的几个方法才是最常用的方法. 3.1.1. 什么是变换计算机图形学是建立在解析几何基础之上的. 也就是说所有绘制的图形都是基于坐标进行计算得到的. 那么利用坐标系位置的调整, 同样的坐标可以得到不同的效果. 例如有一个点 A ( 10, 10 ). 可以在坐标系中绘制出该点.如果调整坐标系. 比如将坐标系向右移动 10 个单位, 得到此时同样是 A 点, 坐标就变成了 ( 0, 10 ). 然后再把坐标系向上移动 10 个单位, 得到那么针对新坐标系, 这个点的坐标就是 ( 0, 0 ). 这个就是坐标变换. 通过移动坐标的位置, 对坐标进行旋转, 以及对坐标轴数据的缩放, 从而使得原有点的坐标发生变化, 或利用原有的坐标点绘制新的效果.坐标变换有一套完整的数学公式. 利用矩阵可以很容易的表示坐标的所有变换.这里的 a, b, c, d, e, f 就刚好是 transform 函数的 参数.1.其中 a 有时又标记为 m11. 它表示水平缩放.2.其中 b 有时又标记为 m12. 它表示水平倾斜.3.其中 c 有时又标记为 m21. 它表示垂直倾斜.4.其中 d 有时又标记为 m22. 它表示垂直缩放.5.其中 e 有时又标记为 dx. 它表示水平移动.6.其中 f 有时又标记为 dy. 它表示垂直移动. 演示123...ctx.transform( 1, 0, 0, 1, 0, 0 );ctx.fillRect( 0, 0, 100, 100 ); 效果这里矩阵变换会比较复杂, 因此在使用中一般使用简单的, 平移, 旋转 和 缩放 的简单 api. 3.1.2. 平移变换平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了.语法:CanvasRenderingContext2D.translate( x, y )描述:1.该方法将坐标进行平移.2.x 表示水平移动, 正数向右, 负数向左.3.y 表示垂直移动, 正数向下, 负数向上.4.变换可以重复调用, 变换是可以累加的.使用该变换, 常常用于绘制不同位置, 但是形状重复的图形.注意: 变换也会被 “继承”, 开启新路径后依旧保留原先变换. 3.1.3. 旋转变换语法:CanvasRenderingContext2D.rotate( radian )描述:1.该方法将坐标轴进行旋转变换.2.参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转.3.该变换常常用于实现旋转动画等. 3.1.4. 缩放变换语法:CanvasRenderingContext2D.scale( x, y )描述:1.该方法实现水平与垂直的缩放.2.参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.3.参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.4.该变换常常用于放大与缩小, 以及反转的效果. 3.2. 环境前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态. 但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码. Canvas 中引入了状态的保持机制. 使用 CanvasRenderingContext2D.save() 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 CanvasRenderingContext2D.restore() 方法即可.状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态.一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径, 然后绘制结束后 restore, 然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响. 3.3. 优化canvas 在绘制图片的时候, drawImage 方法还支持将一个 canvas 绘制到另一个 canvas 中. 因此使用该功能, 可以在内存中完成复杂的绘图, 将绘制好的半成品再绘制到 canvas 中合成需要的效果. 3.4. 画布保存画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 base64 编码的字符串.语法:Canvas.ToDataURL( type, encoderOptions )描述:1.该方法可以将画布转换成 base64 格式的数据2.type 表示输出类型. 例如: image/png 或 image/jpeg 等3.encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用1234567891011121314...&lt;img id=\"img\"/&gt;...var img = document.getElementById( 'img' );var cas = document.createElement( 'canvas' );cas.width = 100, cas.height = 100;var ctx = cas.getContext( '2d' );ctx.fillStyle = 'pink';ctx.fillRect( 0, 0, 100, 100 );var data = cas.toDataURL( 'image/png', 1 );img.src = data; 3.5. 渐变和图案绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 strokeStyle 和 fillStyle 属性, 只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复.相关方法1.CanvasRenderingContext2D.createLinearGradient()2.CanvasRenderingContext2D.createRadialGradient()3.CanvasRenderingContext2D.createPattern() 3.5.1. 线性渐变语法:CanvasRenderingContext2D.createLinearGradient( x0, y0, x1, y1 )描述:1.该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式.2.该方法有两个参数, 用于表示线型渐变的方向与位置.3.使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间. i.方法语法: CanvasGradient.addColorStop( rate, color ). ii.该方法用于设置在某个比例位置的颜色是什么. rate 的取值是 0 到 1 之间. iii.可以添加多个渐变点.4.然后将该对象赋值给 *Style 属性即可. 案例1234567...var canvasGradient = ctx.createLinearGradient( 0, 25, 200, 25 );canvasGradient.addColorStop( 0, 'blue' );canvasGradient.addColorStop( 1, 'red' );ctx.fillStyle = canvasGradient;ctx.fillRect( 0, 100, 200, 50 ); 效果注意: 渐变点的坐标是基于坐标轴来计算的. 3.5.2. 放射渐变语法:CanvasRenderingContext2D.createRadialGradient( x0, y0, r0, x1, y1, r1 )描述:1.该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆.2.前三个参数分别表示其中一个圆的圆心的坐标, 以及半径.3.后三个参数分别表示另一个圆的圆心的坐标, 以及半径.4.绘制渐变效果用法与线性渐变一样. 案例1234567var x = cas.width / 2, y = cas.height / 2, r = 100;var g = ctx.createRadialGradient( x + r * 2 / 3, y - r * 2 / 3, 0, x + r / 3, y - r / 3, r * 4 / 3 );g.addColorStop( 0, '#fff' );g.addColorStop( 1, '#f00' );ctx.fillStyle = g;ctx.arc( x, y, r, 0, 2 * Math.PI );ctx.fill(); 效果 3.6. 阴影在 Canvas 中还可以给绘制的内容设置阴影. 但是一般不这么用, 因为性能不高.相关属性:1.CanvasRenderingContext2D.shadowBlur 属性表示模糊程度.2.CanvasRenderingContext2D.shadowColor 属性表示模糊颜色.3.CanvasRenderingContext2D.shadowOffsetX 属性表示模糊位置 x 坐标偏移.4.CanvasRenderingContext2D.shadowOffsetY属性表示模糊位置 y 坐标偏移.","tags":[]},{"title":"Canvas 中级篇","date":"2016-12-18T14:12:24.000Z","path":"2016/12/18/Canvas 中级篇/","text":"2.中级篇2.1. 绘制形状绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法1.绘制矩形2.绘制圆弧 2.1.1. 绘制矩形绘制矩形的方法1.CanvasRenderingContext2D.strokeRect2.CanvasRenderingContext2D.fillRect3.CanvasRenderingContext2D.rect注意: rect方法就是矩形路径, 还需要使用 fill 或 stroke 才可以看到效果. 因此一般使用 strokeRect 或 fillRect 直接可以看到结果. 清除矩形区域CanvasRenderingContext2D.clearRect 2.1.1.1. 绘制矩形框语法: CanvasRenderingContext2D.strokeRect( x, y, width. height )描述:1.用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多.2.该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.3.使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法.4.绘制的矩形支持 strokeStyle 设置颜色样式. 案例123... ctx.strokeStyle = 'red'; ctx.strokeRect( 100, 100, 200, 100 ); 效果 2.1.1.2. 绘制填充矩形语法:CanvasRenderingContext2D.fillRect( x, y, width. height )描述:1.用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多.2.该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.3.使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法.4.绘制的矩形支持 fillStyle 设置颜色样式. 案例123...ctx.fillStyle = 'green';ctx.fillRect( 100, 100, 200, 100 ); 效果 2.1.1.3. 清除矩形区域语法:CanvasRenderingContext2D.clearRect( x, y, width, height )描述:1.用于清除画布中的矩形区域的内容.2.参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高. 案例123...ctx.fillRect( 100, 100, 200, 100 );ctx.clearRect( 110, 110, 50, 50 ); 效果 2.1.2. 绘制圆弧绘制圆弧的方法有CanvasRenderingContext2D.arc()CanvasRenderingContext2D.arcTo() 2.1.2.1. 绘制圆弧语法:CanvasRenderingContext2D.arc( x, y, radius. startAngle. endAngle, anticlockwise )描述:1.该方法用于绘制一段弧, 配合开始点的位置 与 stroke 方法或 fill 方法可以绘制扇形.2.方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标.3.参数 radius 表示圆弧半径, 单位为弧度.4.参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向.5.参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选. 案例123456789101112131415161718// 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4...ctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );ctx.stroke();// 为了方便看清楚结构, 绘制坐标轴ctx.beginPath();ctx.strokeStyle = 'red';ctx.moveTo( 50, 200 );ctx.lineTo( 350, 200 );ctx.moveTo( 200, 50 );ctx.lineTo( 200, 350 );ctx.moveTo( 200, 200 );ctx.lineTo( 300, 300 );ctx.stroke(); 效果 2.1.2.1.1. 注意事项1.使用 arc 绘图的时候, 如果没有设置 moveTo 那么会从开始的绘弧的地方作为起始点. 2.如果设置了 moveTo, 那么会连线该点与圆弧的起点.3.如果使用 stroke 方法, 那么会从开始连线到圆弧的起始位置. 如果是 fill 方法, 4.会自动闭合路径填充. 例如 2.1.2.2. 绘制扇形绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可1234567891011121314...ctx.strokeStyle = 'red';ctx.fillStyle = 'pink';ctx.moveTo( 100, 200 );ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );ctx.closePath();ctx.stroke();ctx.beginPath();ctx.moveTo( 300, 200 );ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );ctx.closePath();ctx.fill(); 效果 2.1.2.3. 绘制扇形动画绘制扇形动画, 就是每隔几毫秒( 20 毫秒)擦除以前绘制的内容, 然后在以前绘制的基础上比以前多绘制一点东西. 这里多绘制的内容就是由角度决定. 比如一开始角度从 -Math.PI / 2 开始绘制. 那么每次角度都 +0.1, 直到 绘制到 Math.PI * 3 / 2 为止.12345678910111213141516171819202122...ctx.fillStyle = 'green';var startAngle = -Math.PI / 2, angle = startAngle, x = 200, y = 200, r = 100;var intervalId = setInterval(function () &#123; // 清除之前绘制的内容 ctx.clearRect( 0, 0, cas.width, cas.height ); // 角度增量 angle += 0.1; // 判断是否停止计时器 if ( angle &gt;= Math.PI * 3 / 2 ) &#123; clearInterval( intervalId); angle = Math.PI * 3 / 2; console.log( '绘制完成' ); &#125; // 绘制 ctx.moveTo( x, y ); ctx.arc( x, y, r, startAngle, angle ); ctx.fill();&#125;, 20); 2.1.2.4. 绘制饼形图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//将这个代码放入自调用函数中(function (w)&#123; //计算弧度 function angleToRadio(angle) &#123; return Math.PI / 180 * angle; &#125;//创建一个混入式继承的函数 function extend(o1, o2) &#123; for (var key in o2) &#123; // 判断key值是否属于对象 if (o2.hasOwnProperty(key)) &#123; //如果key是属于o2对象的属性,那么就将这些属性赋值给o1 o1[key] = o2[key]; &#125; &#125; &#125;//创建构造函数//传入的参数分别是绘制饼图的圆点的坐标(x,y),饼图的半径(r),用户输入的数据(data数组) function createPie(x, y, r, data) &#123; //给构造函数添加方法 this.x = x; this.y = y; this.r = r; this.data = data; // 设置颜色 this.colors = ['orange', 'red', 'blue', 'green', 'peru', 'black']; &#125;//给构造函数的原型对象添加方法// 不使用替换原型对象的方式(就可以不手动添加constructor属性了)// 在这里我们使用上面封装的混入式继承的方法 extend(createPie.prototype, &#123; // 在新创建的对象中添加需要继承给createPie的方法 // 添加绘制饼图的方法 draw: function () &#123; // 保存this var that = this; // 计算传入的数组中的数值的和 var num = 0; //前面传入的数组中的元素是对象,forEach遍历获取的是一个个的对象 this.data.forEach(function (obj) &#123; num += obj.val; &#125;) // 计算数值占360度的几份 var baseAngle = 360 / num; // 定义开始的弧度为0,结束的弧度也为0 var startAngle = 0, endAngle = 0, //定义中间角的大小,初始化值为0 lineAngle= 0, lineX,lineY; // 通过遍历数组开始画弧 this.data.forEach(function (obj, index) &#123; /* * 因为是在用函数调用方式,所以this指向的是window * 所以里面的属于对象的属性的都要使用that调用 * 因为ctx是全局变量,所以直接使用就可以 */ //绘制圆弧之前先清除前面的路径(开启新的路径) ctx.beginPath(); // 绘制下一个扇形 /* * 下一个扇形开始的弧度就是上一个扇形结束的弧度---&gt;endAngle=startAngle * 下一个扇形结束的弧度就是上一个扇形结束的弧度+当前扇形的弧度 * ---&gt;endAngle=endAngle+angleToRadio(baseAngle*val) * */ //计算的是度数,不是弧度 startAngle = endAngle; endAngle = endAngle + baseAngle * obj.val; //10,20,30,40,50,60 // 设置饼图的原点 ctx.moveTo(that.x, that.y); // 绘制圆弧 ctx.arc(that.x, that.y, that.r, angleToRadio(startAngle), angleToRadio(endAngle)) ctx.closePath(); // 给扇形填充颜色 ctx.fillStyle = that.colors[index];//0,1,2,3,4,5 ctx.fill(); //startAngle = endAngle; //放到下面的时候,当数组循环完成之后,最后的弧度才能进行赋值,赋值完成之后,就不能再进行填充了 //endAngle = endAngle + baseAngle * val; val=10,20,30,40,50,60----&gt;循环完成了 //计算中间角的值 //中间角的值等于当前扇形的开始的弧度加上当前扇形的弧度的一半 lineAngle=startAngle+baseAngle*obj.val/2; /* * 计算60度位置上的x,y的坐标 * 已知圆点的坐标和半径的长度,通过三角函数求x,y的长度 * x:圆心x+r*Math.cos(angleToRadio(pointAngle)); * y:圆心y+r*Math.sin(angleToRadio(pointAngle)) * * */ lineX=that.x+(that.r+20)*Math.cos(angleToRadio(lineAngle)); lineY=that.y+(that.r+20)*Math.sin(angleToRadio(lineAngle)); //开始画线 ctx.beginPath(); ctx.moveTo(that.x,that.y); ctx.lineTo(lineX,lineY); ctx.strokeStyle=that.colors[index]; ctx.stroke(); // 设置文字 // 进行判断,如果在90度--270度之间那么字体就右对齐 if(lineAngle&gt;=90&amp;&amp;lineAngle&lt;=270)&#123; ctx.textAlign=\"right\"; &#125;else &#123; ctx.textAlign=\"left\"; &#125; ctx.fillText(obj.msg,lineX,lineY); &#125;) &#125; &#125;)// 将构造函数暴露在全局中 w.createPie=createPie;&#125;(window)) 1234567891011&lt;body&gt;&lt;canvas id=\"cvs\" width=500 height=500&gt;&lt;/canvas&gt;&lt;script src=\"js/pie.js\"&gt;&lt;/script&gt;&lt;script&gt; var cvs=document.getElementById(\"cvs\"); var ctx=cvs.getContext('2d');// 创建新的对象 var pie=new createPie(100,100,50,[10,20,30,50,20,60]); pie.draw();&lt;/script&gt;&lt;/body&gt; 2.2. 绘制文本绘制文本的方法1.CanvasRenderingContext2D.fillText()2.CanvasRenderingContext2D.strokeText()3.CanvasRenderingContext2D.measureText()文本样式1.CanvasRenderingContext2D.font2.CanvasRenderingContext2D.textAlign3.CanvasRenderingContext2D.textBaseline 2.2.1. 绘制文字语法:1.CanvasRenderingContext2D.strokeText( text, x, y[, maxWidth] )2.CanvasRenderingContext2D.fillText( text, x, y[, maxWidth] )描述:1.这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.2.stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.3.最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制. #### 案例123456...ctx.strokeRect( 100, 100, 200, 50 );ctx.strokeText( 'Hello JK', 100, 100 );ctx.strokeRect( 100, 200, 200, 50 );ctx.fillText( 'Hello JK', 100, 200 ); 效果注意: 第一个文字由于中间空心, 所以文字相当于双线显示. 就显得较粗.根据绘制的矩形块可以发现文字几乎使用该点作为文字基线参考 2.2.2. 计算文本尺寸语法:CanvasRenderingContext2D.measureText()描述:1.该方法返回一个文本尺寸对象, TextMetrics 对象.2.TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度. 2.2.3. 设置文字属性2.2.3.1. 设置文字字体语法:CanvasRenderingContext2D.font = value描述:1.该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等.2.其顺序可以是: style | variant | weight | size/line-height | family.3.默认值为 10px sans-serif4.修改字号后查看 strokeText 与 fillText 的区别1234567...ctx.font = '50px 黑体';ctx.strokeRect( 100, 100, 200, 50 );ctx.strokeText( 'Hello JK', 100, 100 );ctx.strokeRect( 100, 200, 200, 50 );ctx.fillText( 'Hello JK', 100, 200 ); 效果 2.2.3.2. 设置字体水平对齐方式语法:CanvasRenderingContext2D.textAlign = value描述:1.该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等.2.该属性可以设置的值有: start( 默认 ), end, left, right, center.3.start 表示根据参考基准点的垂直直线左靠对齐1234567891011...ctx.moveTo( 150, 100 );ctx.lineTo( 150, 200 );ctx.moveTo( 100, 150 );ctx.lineTo( 200, 150 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textAlign = 'start'; // 默认ctx.fillText( '测试文字', 150, 150 ); 效果end 表示根据参考基准点的垂直直线右靠对齐1234...ctx.font = '30px 黑体';ctx.textAlign = 'end';ctx.fillText( '测试文字', 150, 150 ); 效果left 与 right 就是左对齐与右对齐的意思123456...ctx.font = '30px 黑体';ctx.textAlign = 'left';ctx.fillText( 'left', 150, 150 );ctx.textAlign = 'right'ctx.fillText( 'right', 150, 150 ); 效果最后 center 就是居中的含义.123ctx.font = '50px 黑体'ctx.textAlign = 'center';ctx.fillText( '00000', 150, 150 ); 效果 2.2.3.3. 设置字体垂直对齐方式语法:CanvasRenderingContext2D.textBaseline = value描述:1.该方法设置文字在垂直方向上的对齐方式.2.该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐.alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母.3.ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下.所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle.4.top, middle, bottom 使用的较多1234567891011121314151617181920212223242526272829303132333435...// ------------------ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textBaseline = 'top';ctx.fillText( 'abfghijklpqrty', 150, 80 );// ------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textBaseline = 'bottom';ctx.fillText( 'abfghijklpqrty', 150, 80 );// ------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textBaseline = 'middle';ctx.fillText( 'abfghijklpqrty', 150, 80 ); 效果alphabetic 表示字母参考线, ideographic 会比它低一点, hanging 表示悬挂.1234567891011121314151617181920212223242526272829303132333435ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textBaseline = 'alphabetic';ctx.fillText( 'abfghijklpqrty', 150, 80 ); // -------------------------------------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textBaseline = 'ideographic';ctx.fillText( 'abfghijklpqrty', 150, 80 ); // -------------------------------------------------ctx.translate( 0, 100 );ctx.moveTo( 100, 80 );ctx.lineTo( 500, 80 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textBaseline = 'hanging';ctx.fillText( 'abfghijklpqrty', 150, 80 ); 效果 2.3. 绘制图片绘制图像虽然只有一个 drawImage 函数, 但是该函数有多重参数形式.1.CanvasRenderingContext2D.drawImage( img, dx, dy ).2.CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight ).3.CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ). 2.3.1. 绘制简单图像语法:CanvasRenderingContext2D.drawImage( img, dx, dy )描述:1.使用三个参数, 允许在画布上的 任意位置 绘制图片.2.需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载.3.准备一张网络图片, 绘制, 便于查看其加载过程.123456789// 随便从百度中搜索 '美女头像', 记录一个链接地址var url = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg';// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图ctx.drawImage( img, 100, 100 ); 此时没有任何结果, 打开调试工具查看 Net Work因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中.1234567891011// 随便从百度中搜索 '美女头像', 记录一个链接地址var url = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg';// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图img.onload = function () &#123; ctx.drawImage( img, 100, 100 );&#125;; 修改后就可得到效果注意: 这里使用 new Image() 与 document.createElement( ‘img’ ) 是一样的. 2.3.2. 在指定区域内绘制图像当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布. 例如:因此, 需要将其控制在一个矩形区域内绘制.语法:CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight )描述:1.参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始.2.该方法绘制的图像会在指定范围内被压缩显示.3.将上面的图绘制在 100 * 100 的范围内.12...ctx.drawImage( img, 100, 100, 100, 100 ); 效果如果希望正常显示, 需要固定一个宽度或者高度, 然后根据比例计算出另一个值. 这里假定高度是 100. 计算宽度后绘图.123456...var heigth = 100, width;img.onload = function () &#123; width = img.width * height / img.height; ctx.drawImage( img, 100, 100, width, height );&#125;; 效果 2.3.3. 绘制任意图像类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护. 那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区. 语法:CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 描述: 这里的带有 s 前缀的参数就是指图源的矩形区域. 例如将图片的 ( 100, 100, 300, 200 ) 处的内容绘制到页面的 ( 100, 100, 300, 200 ) 的位置.12...ctx.drawImage( img, 100, 100, 300, 200, 100, 100, 300, 200 ); 效果","tags":[]},{"title":"Canvas 基本篇","date":"2016-12-18T13:23:34.000Z","path":"2016/12/18/Canvas 初级篇/","text":"1.基本篇1.1. 什么是Canvascanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.1canvas 英 [&apos;kænvəs] 美 [&apos;kænvəs] 帆布 画布 1.1.1.canvas 的基本用法基本语法1&lt;canvas&gt;&lt;/canvas&gt; 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.canvas 的使用领域canvas 的使用领域很多: 游戏 可视化数据(重点) banner 广告 多媒体 未来 模拟仿真 远程操作 图形编辑1.2基本绘图1.2.1. 基本绘图方法绘图步骤 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 &#39;2d&#39;. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath().01-绘制基本线1234567891011121314151617var canvas = document.createElement( 'canvas' );canvas.width = 500;canvas.height = 400;canvas.style.border = '1px dashed red';document.body.appendChild( canvas );// 获得 CanvasRenderingContext2D 对象var context = canvas.getContext( '2d' );// 设置 起点context.moveTo( 0, 0 );// 绘制直线context.lineTo( 500, 400 );// 设置 起点context.moveTo( 0, 400 );// 绘制直线context.lineTo( 500, 0 );// 描边显示效果context.stroke(); 运行结果为 1.2.1.1. 计算机直角坐标系 1.2.1.2. 代码分析 需要绘图就需要有 canvas 标签, 该标签用于展示图像. canvas 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置. 但是 canvas 只是展示图像的标签, 它没有绘图的能力. 需要使用 canvas 的上下文工具来实现绘图. 使用 canvas.getContext( &#39;2d&#39; ) 可以获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. 需要绘图, 首选设置绘图的起点. 使用 canvas 绘图, 需要主要的是他主张先描点, 再连线绘制效果. 因此需要首先设置起点, 然后在起点的基础上描述其他需要的点. 使用 CanvasRenderingContext2D.moveTo( x, y ) 方法设置起点. 其中 x, y 表示的是在坐标系中的位置. 使用 CanvasRenderingContext2D.lineTo( x, y ) 来描述绘制直线的下一个点. 依次类推可以描述多个点. 描点结束后, 需要使用CanvasRenderingContext2D.stroke() 方法来连线. 开可以显示出效果.1.2.1.3. getContext 方法语法: Canvas.getContext( typeStr )描述: 该方法用于绘制上下文工具. 如果是绘制平面图形使用 &#39;2d&#39; 作为参数, 如果绘制立体图形使用 &#39;webgl&#39;. 使用 &#39;2d&#39;返回CanvasRenderingContext2D 类型的对象. 使用 &#39;webgl&#39; 返回 WebGLRenderingContext类型的对象.1.2.1.4. moveTo 方法语法: CanvasRenderingContext2D.moveTo( x, y )描述: 该方法用于设置绘制起点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.5. lineTo 方法语法: CanvasRenderingContext2D.lineTo( x, y )描述: 该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.6. stroke 方法语法: CanvasRenderingContext2D.stroke()描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来.1.2.1.7. 结论 绘图先要获得上下文, 即绘图工具 绘图需要设置开始的坐标 绘图是先描点, 然后一个一个依次连线 依次绘图只能绘制单一样式( 色彩等 )1.2.2. 直线图形分别绘制下面的图形: 绘制直线计算坐标. 描边调用 CanvasRenderingContext2D.stroke() 方法. 填充使用 CanvasRenderingContext2D.fill() 方法.1.2.2.1. fill 方法语法: CanvasRenderingContext2D.fill()描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色.1.2.3. 非零环绕原则填充满足非零环绕数原则说明: 在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西. 在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果. 每一个路径都是一个状态.1.2.4. 闭合路径1.2.4.1. closePath 方法语法: CanvasRenderingContext2D.closePath()描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来.举个栗子123456...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.lineTo( 300, 200 );ctx.closePath();ctx.stroke(); 结果为 1.2.5. 路径的概念 路径就是一次绘图 类比使用油漆刷墙面 首先打底色, 绝对不会一次性使用多个色彩 一定是先画完某一个色彩再考虑另一个色彩 除非需要自己创作才会考虑墙面绘画 路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域. 如果需要开启新的绘制, 那么使用 CanvasRenderingContext2D.beginPath() 方法.示例如果需要在一个区域内绘制描边的图形和填充的图形.例如1.2.6. 线型相关属性设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果 CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.lineCap 设置线末端类型. CanvasRenderingContext2D.lineJoin设置相交线的拐点. CanvasRenderingContext2D.getLineDash()获得线段样式数组. CanvasRenderingContext2D.setLineDash()设置线段样式. CanvasRenderingContext2D.lineDashOffset绘制线段偏移量.1.2.6.1. 设置线宽语法: CanvasRenderingContext2D.lineWidth = number描述: 设置线宽.例子12345678910...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineWidth = 10;ctx.moveTo( 100, 250 );ctx.lineTo( 300, 250 );ctx.stroke(); 效果 1.2.6.2. 设置线末端类型语法: CanvasRenderingContext2D.lineCap = value描述: 设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’. ‘butt’ 表示两端使用方形结束. ‘round’ 表示两端使用圆角结束. ‘square’ 表示突出的圆角结束.例子123456789101112131415...ctx.lineWidth = 10;ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'round';ctx.moveTo( 100, 130 );ctx.lineTo( 300, 130 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'square';ctx.moveTo( 100, 160 );ctx.lineTo( 300, 160 );ctx.stroke(); 效果 1.2.6.3. 设置相交线的拐点语法: CanvasRenderingContext2D.lineJoin = value描述: 设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认) ‘round’ 使用圆角连接. ‘bevel’ 使用平切连接. ‘miter’ 使用直角转.例子12345678910111213141516171819...ctx.lineWidth = 10;ctx.lineJoin = 'round';ctx.moveTo( 100, 100 );ctx.lineTo( 200, 200 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'bevel';ctx.moveTo( 100, 150 );ctx.lineTo( 200, 250 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'miter';ctx.moveTo( 100, 200 );ctx.lineTo( 200, 300 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.4. 虚线语法: CanvasRenderingContext2D.lineDashOffset = number CanvasRenderingContext2D.getLineDash() CanvasRenderingContext2D.setLineDash()描述: setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移. getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.demo12345678910111213141516171819202122232425262728...ctx.moveTo( 100, 90 );ctx.lineTo( 100, 110 );ctx.moveTo( 300, 90 );ctx.lineTo( 300, 110 );ctx.moveTo( 100, 140 );ctx.lineTo( 100, 160 );ctx.moveTo( 300, 140 );ctx.lineTo( 300, 160 );ctx.moveTo( 100, 190 );ctx.lineTo( 100, 210 );ctx.moveTo( 300, 190 );ctx.lineTo( 300, 210 );ctx.stroke();ctx.beginPath();ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.setLineDash( [ 5, 5 ] );ctx.moveTo( 100, 150 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineDashOffset = -2;ctx.moveTo( 100, 200 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.5. 填充与描边样式语法: CanvasRenderingContext2D.strokeStyle = value CanvasRenderingContext2D.fillStyle = value描述: strokeStyle 可以设置描边颜色, 与 CSS 的语法一样 fillStyle 设置填充颜色, 与 CSS 语法一样 这两个属性还可以设置渐变对象.demo123456789for (var i=0;i&lt;6;i++)&#123; for (var j=0;j&lt;6;j++)&#123; ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + Math.floor(255-42.5*j) + ')'; ctx.beginPath(); ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true); ctx.stroke(); &#125; &#125; 效果 绘制折线图(等比例缩放)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(function (w) &#123; // 创建一个构造函数 function Line(ctx,data,padding,arrow)&#123; this.ctx=ctx;// 判断,如果没有传入padding的话,那么就直接使用定义的这个数 this.padding=padding||&#123;top:10,right:10,bottom:10,left:10&#125;;// 箭头的的大小 this.arrow=arrow||&#123;width:10,height:20&#125;;// 上顶点 this.vertextTop=&#123; x:this.padding.left, y:this.padding.top &#125;// 右顶点 this.vertextRight=&#123; x:this.ctx.canvas.width-this.padding.right, y:this.ctx.canvas.height-this.padding.bottom &#125;// 原点 this.origin=&#123; x:this.padding.left, y:this.ctx.canvas.height-this.padding.bottom &#125;// 传入的数组 this.data=data;// 计算坐标轴的最大值 this.coordWidth=this.ctx.canvas.width-this.padding.left-this.padding.right; this.coordHeight=this.ctx.canvas.height-this.padding.top-this.padding.bottom; &#125;// 替换原型对象 Line.prototype=&#123;// 手动添加contructor属性 constructor:Line,// 在原型中添加方法// 将封装的方法综合到一个方法中,外面可以调用一次就可以 draw: function () &#123; this.drawVertext(); this.drawArrow(); this.drawLine(); &#125;,// 绘制坐标轴 drawVertext: function () &#123;// 在绘制前先清除路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.origin.x,this.origin.y); this.ctx.lineTo(this.vertextRight.x,this.vertextRight.y); this.ctx.stroke(); &#125;,// 绘制箭头 drawArrow:function ()&#123;// 上箭头// 绘制前先清除路径,开启新的路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.vertextTop.x-this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.lineTo(this.vertextTop.x,this.vertextTop.y+this.arrow.height/2); this.ctx.lineTo(this.vertextTop.x+this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.closePath(); this.ctx.stroke();// 右箭头 this.ctx.beginPath(); this.ctx.moveTo(this.vertextRight.x,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y-this.arrow.width/2); this.ctx.lineTo(this.vertextRight.x-this.arrow.height/2,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y+this.arrow.width/2); this.ctx.closePath(); this.ctx.stroke(); &#125;,// 绘制折线 drawLine: function () &#123; // 保存this var that =this; that.ctx.beginPath()// 计算x轴上的缩放比例 var radioX=this.coordWidth/this.data.length;// 计算y轴上的缩放比例 var radioY=this.coordHeight/Math.max.apply(null,this.data);// 通过用户传进来的数据进行绘制折线 this.data.forEach(function (val, index) &#123;// 可以根据坐标轴的原点来绘制点 that.ctx.fillRect(that.origin.x+index*radioX-5,that.origin.y-val*radioY-5,10,10); &#125;)// 绘制折线 this.data.forEach(function (val,index) &#123; that.ctx.lineTo(that.origin.x+index*radioX,that.origin.y-val*radioY); &#125;); this.ctx.stroke(); &#125; &#125;// 将window当作参数传进来,让构造函数暴露在全局变量中 w.Line=Line;&#125;(window)) 效果","tags":[]},{"title":"AngularJS","date":"2016-11-24T11:42:44.000Z","path":"2016/11/24/AngularJS/","text":"123&lt;div&gt; hello world&lt;/div&gt;","tags":[]},{"title":"配置android环境是出现的错误以及解决方法","date":"2016-10-18T07:03:13.000Z","path":"2016/10/18/android项目搭建出现的问题以及解决方法/","text":"项目搭建的基本步骤项目依赖环境搭建 cordova(打包工具) npm install -g cordova ionic(框架) npm install -g ionic 创建项目模板 ionic start 项目名称 (默认情况下创建带有tab栏的模板) ionic start myApp blank(创建一个空白的模板) ionic start myApp tabs(创建一个带有tab栏的模板) ionic start myApp sidemenu(创建一个带有侧边栏的模板) 打包app 添加项目平台 android ==&gt; ionic platform add android ios ==&gt; ionic planform add ios 打包 android ==&gt; ionic build android ios ==&gt; ionic build ios 直接运行在手机上 ionic run android 打包过程中出现的问题不要使用中文路径,不然会报错出错原因：直接从npm上下载，网速太慢导致报错解决办法：使用淘宝镜像，不过不好的一点是，淘宝镜像上的版本可能不是最新的;翻墙.错误原因:没有手动安装相应的android-23版本的文件解决方法:去相应的网站上下载android-23版本的文件","tags":[]},{"title":"正则表达式","date":"2016-08-24T08:39:44.000Z","path":"2016/08/24/正则表达式/","text":"","tags":[]},{"title":"Javascript 函数","date":"2016-08-21T02:28:20.000Z","path":"2016/08/21/Javascript-4/","text":"","tags":[]},{"title":"Javascript 数组","date":"2016-08-20T14:03:52.000Z","path":"2016/08/20/Javascript-3/","text":"1 数组的概念1.1 数组的概念数组是一种数据类型.(把很多数据装入一个盒子中,用的时候再取出来) 1.2数组的定义1.2.1 字面量定义1var arr = [1,2,3]; 1.2.2 对象定义(数组的构造函数)12var arr = new Array(参数);参数为一个数值的时候为数组的长度,多个数值时为数组中的元素. 1.3 数组的操作1.3.1 求数组的长度数组的长度 = 数组名.length; 可以通过修改数组的长度来改变数组元素的报个数,如果改小了,数组从后面删除元素.(伪数组的长苏可以修改,但是不能修改里面的元素) 1.3.2 获取数组中的元素数组中的指定元素 = 数组名[索引值]; 数组的索引代表的是数组中的元素在数组中的位置,从0开始.如果会哦去数组中元素是,数组名[索引值],没有制定索引(元素没有那么多),系统报错,而是给定值为undefined. 1.4 遍历数组(获取并操作数组中的每一个元素)1234var arr = [1,2,3];for(var i = 0; i &lt; arr.length; i++)&#123; arr[i]; //操作数组中的每一个元素&#125;","tags":[]},{"title":"JavaScript 流程控制","date":"2016-08-19T06:29:08.000Z","path":"2016/08/19/JavaScript-2/","text":"6 流程控制6.1 顺序结构程序正常执行流程从上往下,从左往右 赋值运算时从右往左执行,且左侧为属性或变量,不取值 6.2 选择结构共有两种，if语句和switch语句。If常用，switch为特殊情况使用，判断条件出现的情况特别多的时候用switch，其他时候if语句比较方便。 6.2.1 If语句 if语句用法有三种 if(条件1){程序1} if(条件1){程序1} else{程序2} if(条件1){程序1}else if(条件2){程序2}…else{程序n} 三目运算(三元运算) 1表达式1 ? 值1 : 值2 6.2.2 switch语句1234567891011switch(值1)&#123; case value1: 程序1; break; //break关键字会导致代码执行流跳出switch语句 case value2: 程序2; break; default: 程序3;&#125; break可以省略，如果省略，代码会继续执行下一个case switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换 判断当天是周几?123456789101112131415161718192021222324252627282930// 需求：弹框显示今天是星期几。// 步骤：// 1.获取当天是星期几。// 2.判断星期几，弹簧弹窗显示 var date = new Date();// console.log(date.getDay());//礼拜日给我们的值将是0 var num = date.getDay(); switch (num)&#123; case 0: alert(\"星期日\"); break; case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; case 6: alert(\"星期六\"); &#125; 6.3 循环结构1．遍历数组首选for循环，简单循环使用for。2．而while循环强调，不记循环次数（不知道循环多少次），首选while。3．最后do…while循环强调，无论怎样，至少执行一次是，使用do…while。 6.3.1 for循环 执行流程for (变量;条件1;条件2){ 执行程序 }执行过程：变量-&gt;条件1-&gt;执行程序-&gt;条件2-&gt;条件1-&gt;执行程序…..直到条件1不成立，跳出循环。 三个表达式均为可选，但是必须写分号！！！for(;;){程序} 死循环;demo1234567891011121314//求1-100之间所有偶数的和、所有奇数的和 var sumOdd = 0;//奇数和 var sumEven = 0;//偶数和 for(var i=1;i&lt;=100;i++)&#123; //判断如果是奇数加到sumOdd，如果是偶数加到sumEven if(i%2 === 1)&#123; sumOdd += i; &#125;else&#123; sumEven += i; &#125; &#125; console.log(sumOdd); console.log(sumEven); 1234567891011121314//本金10000元存入银行，年利率是千分之三，每过1年，将本金和利息相加作为新的本金。计算5年后，获得的本金是多少？//需求：本金10000，利率千分之3，求5年本息和。//步骤：//1：利用for循环，把每年的利息添加到本金中作为第二年的本金//2：一共循环五次var money = 10000;var rote = 0.003;for(var i=1;i&lt;=5;i++)&#123;//money = money+money*rote);//money = money*(1+rote);//money *= (1+rote); money *= 1+rote;&#125;alert(money); 1234567891011121314151617181920212223242526 //有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？// 兔子的规律为数列，1，1，2，3，5，8，13，21 // n1 n2 n3=n1+n2,n4=n2+n3,n5=n4+n3...... //斐波那契数列：1，1，2，3，5，8，13，21，34，55，89，144........... //需求：求斐波那契数列第12项是多少？ //思路：设置两个变量，分别代表第一个和第二个数值，然后从第三项开始，当前项等于前两项之和。在赋值之前，先把后一项保存起来，赋值完毕在把保存值赋值给第一项。 //步骤： //1.定义两个变量和一个中间值 //2.然后利用循环交换变量和以及变量 //3.直接打印n2 //1.定义两个变量和一个中间值 var num1 = 1; var num2 = 1; //2.然后利用循环交换变量和以及变量(循环次数 = 从第三项开始循环，到第12项结束) for(var i=3;i&lt;=12;i++)&#123; var temp = num2; num2 = num1+num2; num1 = temp;// num1 = num2-num1; &#125; //3.直接打印num2 alert(num2); 打印正方形和三角形1234567891011//需求：打印宽9，长9的正方形。//for(var k=1;k&lt;=9;k++)&#123; for(var j=1;j&lt;=9;j++)&#123; for(var i=1;i&lt;=9;i++)&#123; document.write(\"☆\"); &#125; document.write(\"&lt;br&gt;\"); &#125;// document.write(\"&lt;br&gt;\");//&#125;document.write(\"&lt;br&gt;\"); 1234567//需求：打印三角形(外循环控制行，内循环控制列) for(var j=1;j&lt;=9;j++)&#123; for(var i=1;i&lt;=j;i++)&#123; document.write(\"☆\"); &#125; document.write(\"&lt;br&gt;\"); &#125; 打印九九乘法表123456789for(var i=1;i&lt;=9;i++)&#123; for(var j=1;j&lt;=i;j++)&#123; document.write(i+\"*\"+j+\"=\"+i*j+\" \"); &#125; document.write(\"&lt;br&gt;\"); &#125; document.write(\"&lt;table border='1'&gt;\"); //在这里面利用for循环输出tr和td... document.write(\"&lt;/table&gt;\"); 6.3.2 while循环","tags":[]},{"title":"JavaScript 基础篇","date":"2016-08-18T08:39:47.000Z","path":"2016/08/18/JavaScript-1/","text":"1 JavaScript概述1.1 JS作用1.验证表单(以前的网速慢,最初的目的)2.页面特效(PC端的网页特效)3.移动端(移动web和app)4.异步和服务器交互(Ajax)5.服务端开发(nodejs) 1.2 浏览器是如何工作的 1.3 JS是弱类型脚本语言JavaScript是世界上用的最多的脚本语言. 脚本语言:不需要编译,直接运行在浏览器,边解析边执行的的语言. JavaScript是一种客户端的脚本语言. 1.3.1 解析执行与编译执行 编译执行:把代码编译成CPU认识的语言(文件,然后整体的执行) 解析执行:一行一行解析,解析一行执行一行 1.3.2弱类型脚本语言 脚本语言:弥补编译语言的不足而存在的,作为补充语言,不用编译. 弱类型语言:简单理解定义一个变量,可以有多种数据类型. 1.4 组成(前端标准和JS组成)1.4.1 前端标准(HTML/CSS/JS) HTML 提供网页上显示的内容 CSS 美化网页(样式) JS 控制网页行为(行为)设计原则:结构/样式/行为的分离 1.4.2 JS组成1JS = ECMAScript + DOM + BOM + 高级 1.ECMAScript(前身为欧洲计算机制造商协会) JavaScript的语法规范2.DOM(Document Object Model) JavaScript操作网页上元素的API3.BOM(Browser Object Model) JavaScript操作浏览器部分功能的API 1.5 输出语句123console.log(\"内容\"); 在控制台打印输出的内容alert(\"内容\"); 弹窗显示内容document.write(\"内容\"); 在页面书写内容 1.6 引入方式1.6.1 内嵌式123alert(&quot;我是内嵌式&quot;);prompt(&quot;请输入：&quot;);confirm(&quot;你好吗？&quot;); 1.6.2 外链式 单行注释//单行注释 多行注释/* 多行注释 */ 注释的应用 注释一般用于解释某些复杂代码的逻辑，方便与后期的维护和开发 注释一般用于对整个模块进行分割划分，方便于代码查找代码和维护 注释一般用于：模块、函数、复杂逻辑注解、文件注解、维护记录等 2 变量2.1 命名规范 驼峰命名规则：getElementById/matherAndFather/aaaOrBbbAndCcc 遵从规则：1.变量命名必须以字母或是下标符号”_”或者”$”为开头。2.变量名长度不能超过255个字符。3.变量名中不允许使用空格，首个字不能为数字。4.不用使用脚本语言中保留的关键字及保留符号作为变量名。5.变量名区分大小写。(javascript是区分大小写的语言)6.汉语可以作为变量名。但是不建议使用！！！（low） 2.2 变量的使用 JavaScript的变量:变量是在计算机中存储数据的一个标识符.变量可以在声明的时候赋值,也可以稍后赋值.2.2.1 定义赋值和定义后再赋值1234567var age = 19; //定义赋值// 定义后再赋值var age;age = 19;//不建议使用跨类型var age = \"张三\";age = 19; 3 数据类型3.1 数据类型划分查看当前变量的数据类型:typeof name / typeof (name) 3.1.1 简单数据类型(值类型) 字符串 – String 数字 – Number 布尔 – Boolean 未定义 – undefined 空 – null 3.1.2 复杂数据类型(引用类型) Object function Array Date RegExp Error 3.2 字面量定义固定的值,让你从”字面上”理解其含义1var age = 18; 3.3 简单数据类型介绍3.3.1 Number1.进制 进制包括2进制/8进制(011)/10进制/16进制(0xA)等等2.浮点数 因为精度丢失问题,所以不判断计算后的两个浮点数是否相等.3.数值范围 由于内存的限制,ECMAScript并不能保存世界上所有的数值 最小值:Number.MIN_VALUE,这个值为:5e-324 最大值:Number.MAX_VALUE,这个值为:1.7976931348623157e+308 无穷大:infinity 无穷小:-infinity4.NaN NaN 非数值(Not a Number) 12console.log('abc'/18);//结果是NaN undefined和任何数值计算都为NaN NaN与任何值都不相等,包括NaN本身 isNaN();任何不能被转换为数值的值都会导致这个函数返回true123isNaN(NaN); //trueisNaN('bule'); // trueisNaN(123); //false 3.3.2 String1.字面量定义方式 用引号时,可单可双,唯独不可一单一双. .length看有几个字符123var name = 'zhangsan';var name = \"zhangsan\";var name = 'zhangsan\"; //这样是错误的,单引号与双引号要成对出现 2.转译 无法输出的字符，先输出/，在输出字符。（“、\\、换行等….）3.字符串不可变 在内存中不会立刻消失,只能二次赋值,原有的字符串在一定时间内被垃圾回收器回收4.字符串拼接 如果两个变量都是字符串,无论是否包含数字,只要是拼接,那么在前一个后面添加后一个字符串. 3.3.3 Boolean1.Boolean类型有两个字面量:true和false,区分大小写 虽然Boolean类型的字面量值只有两个,但是ECMAScript中所有值都有与这两个Boolean值等价的值.2.true true,除了0数字/‘something’/Object为true3.false false/0/“”/undefined/null4.if判断语句会把()内的值强行转换成boolean类型进行判断 3.3.4 undefined和null12345 console.log(undefined == null); //true console.log(undefined === null); //false// 区别:和数字运算时: console.log(10 + null); //10 console.log(10 + undefined); //NaN 任何数据类型和undefined运算都是NaN 任何值和null运算,null可以看作0运算 4 数据类型转换4.1 任何简单类型转换成String(三种方法)1.变量 + “” / 变量 + ‘字符串’.2.String(变量).3.变量.toString(). undefined和null没有toString方法12345678910111213//转换成字符串var bool = true;var num = 111;var aaa;var bbb = null;console.log(typeof(bool+\"\"));console.log(typeof(num+\"\"));console.log(typeof(aaa+\"\"));console.log((aaa+\"\"));console.log(typeof(bbb+\"\"));console.log(typeof(String(bool)));console.log(typeof(num.toString())); 4.2 任何简单类型转换成Number 此转换容易产生NaN,一旦被转换的变量中含有非数字字符,都容易出现NaN1.变量 - * / 一个数字(有非数字字符会出现NaN) 123var num1 = '11' - 0;var num2 = '11' * 1;var num3 = '11' / 1; JS底层做了一个强制类型转换,把字符串转换成了Number进行运算2.Number(变量)(有非数字字符会出现NaN) 1234// 把字符变成数字var num1 = Number('18'); // 结果为18.99数字型(有小数也可以转换)var num2 = Number('18.99'); 3.parseInt()和parseFloat() 空字符串parseInt()和parseFloat()返回NaN，Number(“”)返回0 parseInt(变量): 如果变量中首个字符为字母,则结果为NaN;否则取出现首个非数字前的整数. 123var num = parseInt('123.123aaa'); console.log(num); // 结果为 123 parseFloat(变量): 如果变量中首个字符为字母,则结果为NaN;否则取出现首个非数字前的浮点数.123var num = parseFloat('123.123aaa'); console.log(num); // 结果为123.123 4.特别提示 boolean类型中: true数值为1,false为0; null的数值为0; undefined无数只类型或者为NaN; 任何简单类型转换成Boolean 任何数据类型都可以转换成boolean类型,所以和以往两个转换不同;1.Boolean(变量)1234567var bool = Boolean('111'); console.log(bool); //返回值为 truevar date = new Date(); console.log(Boolean(0));console.log(Boolean(\"\"));console.log(Boolean(null)); 2.!!变量 第一个逻辑非操作会基于无论什么操作数返回一个与之相反的布尔值 第二个逻辑非操作则对该布尔值求反 于是就得到了这个值真正对应的布尔值123console.log(!!1);console.log(!!\"abc\");console.log(!!date); 5 操作符5.1 操作符种类一、算数运算符（+ — * / …） 一元运算符：正号、负号、++、–、平方等一个变量就能运算 二元运算符：+-*/%等两个变量才能运算 三元运算符： 值1？值2：值3；二、逻辑运算符（ ||&amp;&amp; ! ）（或且非）三、比较运算符（&lt;、&gt;、==、&gt;=…）四、赋值运算符（=、+=、-=、*=、/=、%=） 5.2 优先级1.()2.!、-（负数）、++、– （正数省略+）（一元运算）3.、/、%4.+、- （加，减）（二元运算）5.&lt;、&lt;=、&lt;、&gt;= （一级逻辑运算）6.==、!=、===、!==、 （二级逻辑运算）7.&amp;&amp; （三级级逻辑运算）8.||9.?: （三元运算）10.=、+=、-=、=、/=、%= （赋值运算） 5.3 逻辑运算符 &amp;&amp; 与 属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值 只有两个操作数都为true，结果为true 只要有一个操作数为false，结果为false || 或 属于短路操作，如果第一个操作数的求值结果为true ，就不会对第二个操作数求值了 有一个操作数为true，结果为true 有一个操作数false，结果为false ! 非 逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反只有一个操作数 5.4 短路操作 与 如果第一个操作数是对象，返回第二个操作数 如果第二个操作数是对象，并且第一个操作数是true返回第二个操作数 如果有一个操作数是null（NaN/undefined），返回null（NaN/undefined） &amp;&amp;链接两个boolean类型,有一个是false结果就是false 1231 = 2 &amp;&amp; 1;0 = 0 &amp;&amp; 1;// 都是true取后面的,都是false取前面的 或 如果第一个操作数是对象，返回第一个操作数 如果第二个操作数是对象，并且第一个操作数是false返回第二个操作数 如果两个操作数都是对象，返回第一个操作数 如果两个操作数都是是null（NaN/undefined），返回null（NaN/undefined） ||链接两个boolean类型,有一个是true结果就是true1232 = 2 || 1;1 = 0 || 1;//都是true取前面,都是false取后面","tags":[]}]