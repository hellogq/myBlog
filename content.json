[{"title":"Canvas 中级篇","date":"2016-12-18T14:12:24.000Z","path":"2016/12/18/Canvas 中级篇/","text":"2.中级篇2.1. 绘制形状绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法1.绘制矩形2.绘制圆弧 2.1.1. 绘制矩形绘制矩形的方法1.CanvasRenderingContext2D.strokeRect2.CanvasRenderingContext2D.fillRect3.CanvasRenderingContext2D.rect注意: rect方法就是矩形路径, 还需要使用 fill 或 stroke 才可以看到效果. 因此一般使用 strokeRect 或 fillRect 直接可以看到结果. 清除矩形区域CanvasRenderingContext2D.clearRect 2.1.1.1. 绘制矩形框语法: CanvasRenderingContext2D.strokeRect( x, y, width. height )描述:1.用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多.2.该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.3.使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法.4.绘制的矩形支持 strokeStyle 设置颜色样式. 案例123... ctx.strokeStyle = 'red'; ctx.strokeRect( 100, 100, 200, 100 ); 效果 2.1.1.2. 绘制填充矩形语法:CanvasRenderingContext2D.fillRect( x, y, width. height )描述:1.用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多.2.该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.3.使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法.4.绘制的矩形支持 fillStyle 设置颜色样式. 案例123...ctx.fillStyle = 'green';ctx.fillRect( 100, 100, 200, 100 ); 效果 2.1.1.3. 清除矩形区域语法:CanvasRenderingContext2D.clearRect( x, y, width, height )描述:1.用于清除画布中的矩形区域的内容.2.参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高. 案例123...ctx.fillRect( 100, 100, 200, 100 );ctx.clearRect( 110, 110, 50, 50 ); 效果 2.1.2. 绘制圆弧绘制圆弧的方法有CanvasRenderingContext2D.arc()CanvasRenderingContext2D.arcTo() 2.1.2.1. 绘制圆弧语法:CanvasRenderingContext2D.arc( x, y, radius. startAngle. endAngle, anticlockwise )描述:1.该方法用于绘制一段弧, 配合开始点的位置 与 stroke 方法或 fill 方法可以绘制扇形.2.方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标.3.参数 radius 表示圆弧半径, 单位为弧度.4.参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向.5.参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选. 案例123456789101112131415161718// 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4...ctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );ctx.stroke();// 为了方便看清楚结构, 绘制坐标轴ctx.beginPath();ctx.strokeStyle = 'red';ctx.moveTo( 50, 200 );ctx.lineTo( 350, 200 );ctx.moveTo( 200, 50 );ctx.lineTo( 200, 350 );ctx.moveTo( 200, 200 );ctx.lineTo( 300, 300 );ctx.stroke(); 效果 2.1.2.1.1. 注意事项1.使用 arc 绘图的时候, 如果没有设置 moveTo 那么会从开始的绘弧的地方作为起始点. 2.如果设置了 moveTo, 那么会连线该点与圆弧的起点.3.如果使用 stroke 方法, 那么会从开始连线到圆弧的起始位置. 如果是 fill 方法, 4.会自动闭合路径填充. 例如 2.1.2.2. 绘制扇形绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可1234567891011121314...ctx.strokeStyle = 'red';ctx.fillStyle = 'pink';ctx.moveTo( 100, 200 );ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );ctx.closePath();ctx.stroke();ctx.beginPath();ctx.moveTo( 300, 200 );ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );ctx.closePath();ctx.fill(); 效果 2.1.2.3. 绘制扇形动画绘制扇形动画, 就是每隔几毫秒( 20 毫秒)擦除以前绘制的内容, 然后在以前绘制的基础上比以前多绘制一点东西. 这里多绘制的内容就是由角度决定. 比如一开始角度从 -Math.PI / 2 开始绘制. 那么每次角度都 +0.1, 直到 绘制到 Math.PI * 3 / 2 为止.12345678910111213141516171819202122...ctx.fillStyle = 'green';var startAngle = -Math.PI / 2, angle = startAngle, x = 200, y = 200, r = 100;var intervalId = setInterval(function () &#123; // 清除之前绘制的内容 ctx.clearRect( 0, 0, cas.width, cas.height ); // 角度增量 angle += 0.1; // 判断是否停止计时器 if ( angle &gt;= Math.PI * 3 / 2 ) &#123; clearInterval( intervalId); angle = Math.PI * 3 / 2; console.log( '绘制完成' ); &#125; // 绘制 ctx.moveTo( x, y ); ctx.arc( x, y, r, startAngle, angle ); ctx.fill();&#125;, 20); 2.1.2.4. 绘制饼形图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//将这个代码放入自调用函数中(function (w)&#123; //计算弧度 function angleToRadio(angle) &#123; return Math.PI / 180 * angle; &#125;//创建一个混入式继承的函数 function extend(o1, o2) &#123; for (var key in o2) &#123; // 判断key值是否属于对象 if (o2.hasOwnProperty(key)) &#123; //如果key是属于o2对象的属性,那么就将这些属性赋值给o1 o1[key] = o2[key]; &#125; &#125; &#125;//创建构造函数//传入的参数分别是绘制饼图的圆点的坐标(x,y),饼图的半径(r),用户输入的数据(data数组) function createPie(x, y, r, data) &#123; //给构造函数添加方法 this.x = x; this.y = y; this.r = r; this.data = data; // 设置颜色 this.colors = ['orange', 'red', 'blue', 'green', 'peru', 'black']; &#125;//给构造函数的原型对象添加方法// 不使用替换原型对象的方式(就可以不手动添加constructor属性了)// 在这里我们使用上面封装的混入式继承的方法 extend(createPie.prototype, &#123; // 在新创建的对象中添加需要继承给createPie的方法 // 添加绘制饼图的方法 draw: function () &#123; // 保存this var that = this; // 计算传入的数组中的数值的和 var num = 0; //前面传入的数组中的元素是对象,forEach遍历获取的是一个个的对象 this.data.forEach(function (obj) &#123; num += obj.val; &#125;) // 计算数值占360度的几份 var baseAngle = 360 / num; // 定义开始的弧度为0,结束的弧度也为0 var startAngle = 0, endAngle = 0, //定义中间角的大小,初始化值为0 lineAngle= 0, lineX,lineY; // 通过遍历数组开始画弧 this.data.forEach(function (obj, index) &#123; /* * 因为是在用函数调用方式,所以this指向的是window * 所以里面的属于对象的属性的都要使用that调用 * 因为ctx是全局变量,所以直接使用就可以 */ //绘制圆弧之前先清除前面的路径(开启新的路径) ctx.beginPath(); // 绘制下一个扇形 /* * 下一个扇形开始的弧度就是上一个扇形结束的弧度---&gt;endAngle=startAngle * 下一个扇形结束的弧度就是上一个扇形结束的弧度+当前扇形的弧度 * ---&gt;endAngle=endAngle+angleToRadio(baseAngle*val) * */ //计算的是度数,不是弧度 startAngle = endAngle; endAngle = endAngle + baseAngle * obj.val; //10,20,30,40,50,60 // 设置饼图的原点 ctx.moveTo(that.x, that.y); // 绘制圆弧 ctx.arc(that.x, that.y, that.r, angleToRadio(startAngle), angleToRadio(endAngle)) ctx.closePath(); // 给扇形填充颜色 ctx.fillStyle = that.colors[index];//0,1,2,3,4,5 ctx.fill(); //startAngle = endAngle; //放到下面的时候,当数组循环完成之后,最后的弧度才能进行赋值,赋值完成之后,就不能再进行填充了 //endAngle = endAngle + baseAngle * val; val=10,20,30,40,50,60----&gt;循环完成了 //计算中间角的值 //中间角的值等于当前扇形的开始的弧度加上当前扇形的弧度的一半 lineAngle=startAngle+baseAngle*obj.val/2; /* * 计算60度位置上的x,y的坐标 * 已知圆点的坐标和半径的长度,通过三角函数求x,y的长度 * x:圆心x+r*Math.cos(angleToRadio(pointAngle)); * y:圆心y+r*Math.sin(angleToRadio(pointAngle)) * * */ lineX=that.x+(that.r+20)*Math.cos(angleToRadio(lineAngle)); lineY=that.y+(that.r+20)*Math.sin(angleToRadio(lineAngle)); //开始画线 ctx.beginPath(); ctx.moveTo(that.x,that.y); ctx.lineTo(lineX,lineY); ctx.strokeStyle=that.colors[index]; ctx.stroke(); // 设置文字 // 进行判断,如果在90度--270度之间那么字体就右对齐 if(lineAngle&gt;=90&amp;&amp;lineAngle&lt;=270)&#123; ctx.textAlign=\"right\"; &#125;else &#123; ctx.textAlign=\"left\"; &#125; ctx.fillText(obj.msg,lineX,lineY); &#125;) &#125; &#125;)// 将构造函数暴露在全局中 w.createPie=createPie;&#125;(window)) 1234567891011&lt;body&gt;&lt;canvas id=\"cvs\" width=500 height=500&gt;&lt;/canvas&gt;&lt;script src=\"js/pie.js\"&gt;&lt;/script&gt;&lt;script&gt; var cvs=document.getElementById(\"cvs\"); var ctx=cvs.getContext('2d');// 创建新的对象 var pie=new createPie(100,100,50,[10,20,30,50,20,60]); pie.draw();&lt;/script&gt;&lt;/body&gt; 2.2. 绘制文本绘制文本的方法1.CanvasRenderingContext2D.fillText()2.CanvasRenderingContext2D.strokeText()3.CanvasRenderingContext2D.measureText()文本样式1.CanvasRenderingContext2D.font2.CanvasRenderingContext2D.textAlign3.CanvasRenderingContext2D.textBaseline 2.2.1. 绘制文字语法:1.CanvasRenderingContext2D.strokeText( text, x, y[, maxWidth] )2.CanvasRenderingContext2D.fillText( text, x, y[, maxWidth] )描述:1.这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.2.stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.3.最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制. #### 案例123456...ctx.strokeRect( 100, 100, 200, 50 );ctx.strokeText( 'Hello JK', 100, 100 );ctx.strokeRect( 100, 200, 200, 50 );ctx.fillText( 'Hello JK', 100, 200 ); 效果注意: 第一个文字由于中间空心, 所以文字相当于双线显示. 就显得较粗.根据绘制的矩形块可以发现文字几乎使用该点作为文字基线参考 2.2.2. 计算文本尺寸语法:CanvasRenderingContext2D.measureText()描述:1.该方法返回一个文本尺寸对象, TextMetrics 对象.2.TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度. 2.2.3. 设置文字属性2.2.3.1. 设置文字字体语法:CanvasRenderingContext2D.font = value描述:1.该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等.2.其顺序可以是: style | variant | weight | size/line-height | family.3.默认值为 10px sans-serif4.修改字号后查看 strokeText 与 fillText 的区别1234567...ctx.font = '50px 黑体';ctx.strokeRect( 100, 100, 200, 50 );ctx.strokeText( 'Hello JK', 100, 100 );ctx.strokeRect( 100, 200, 200, 50 );ctx.fillText( 'Hello JK', 100, 200 ); 效果 2.2.3.2. 设置字体水平对齐方式语法:CanvasRenderingContext2D.textAlign = value描述:1.该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等.2.该属性可以设置的值有: start( 默认 ), end, left, right, center.3.start 表示根据参考基准点的垂直直线左靠对齐1234567891011...ctx.moveTo( 150, 100 );ctx.lineTo( 150, 200 );ctx.moveTo( 100, 150 );ctx.lineTo( 200, 150 );ctx.strokeStyle = 'red';ctx.stroke();ctx.font = '30px 黑体';ctx.textAlign = 'start'; // 默认ctx.fillText( '测试文字', 150, 150 ); 效果","tags":[]},{"title":"Canvas 基本篇","date":"2016-12-18T13:23:34.000Z","path":"2016/12/18/Canvas 初级篇/","text":"1.基本篇1.1. 什么是Canvascanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.1canvas 英 [&apos;kænvəs] 美 [&apos;kænvəs] 帆布 画布 1.1.1.canvas 的基本用法基本语法1&lt;canvas&gt;&lt;/canvas&gt; 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.canvas 的使用领域canvas 的使用领域很多: 游戏 可视化数据(重点) banner 广告 多媒体 未来 模拟仿真 远程操作 图形编辑1.2基本绘图1.2.1. 基本绘图方法绘图步骤 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 &#39;2d&#39;. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath().01-绘制基本线1234567891011121314151617var canvas = document.createElement( 'canvas' );canvas.width = 500;canvas.height = 400;canvas.style.border = '1px dashed red';document.body.appendChild( canvas );// 获得 CanvasRenderingContext2D 对象var context = canvas.getContext( '2d' );// 设置 起点context.moveTo( 0, 0 );// 绘制直线context.lineTo( 500, 400 );// 设置 起点context.moveTo( 0, 400 );// 绘制直线context.lineTo( 500, 0 );// 描边显示效果context.stroke(); 运行结果为 1.2.1.1. 计算机直角坐标系 1.2.1.2. 代码分析 需要绘图就需要有 canvas 标签, 该标签用于展示图像. canvas 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置. 但是 canvas 只是展示图像的标签, 它没有绘图的能力. 需要使用 canvas 的上下文工具来实现绘图. 使用 canvas.getContext( &#39;2d&#39; ) 可以获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. 需要绘图, 首选设置绘图的起点. 使用 canvas 绘图, 需要主要的是他主张先描点, 再连线绘制效果. 因此需要首先设置起点, 然后在起点的基础上描述其他需要的点. 使用 CanvasRenderingContext2D.moveTo( x, y ) 方法设置起点. 其中 x, y 表示的是在坐标系中的位置. 使用 CanvasRenderingContext2D.lineTo( x, y ) 来描述绘制直线的下一个点. 依次类推可以描述多个点. 描点结束后, 需要使用CanvasRenderingContext2D.stroke() 方法来连线. 开可以显示出效果.1.2.1.3. getContext 方法语法: Canvas.getContext( typeStr )描述: 该方法用于绘制上下文工具. 如果是绘制平面图形使用 &#39;2d&#39; 作为参数, 如果绘制立体图形使用 &#39;webgl&#39;. 使用 &#39;2d&#39;返回CanvasRenderingContext2D 类型的对象. 使用 &#39;webgl&#39; 返回 WebGLRenderingContext类型的对象.1.2.1.4. moveTo 方法语法: CanvasRenderingContext2D.moveTo( x, y )描述: 该方法用于设置绘制起点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.5. lineTo 方法语法: CanvasRenderingContext2D.lineTo( x, y )描述: 该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.6. stroke 方法语法: CanvasRenderingContext2D.stroke()描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来.1.2.1.7. 结论 绘图先要获得上下文, 即绘图工具 绘图需要设置开始的坐标 绘图是先描点, 然后一个一个依次连线 依次绘图只能绘制单一样式( 色彩等 )1.2.2. 直线图形分别绘制下面的图形: 绘制直线计算坐标. 描边调用 CanvasRenderingContext2D.stroke() 方法. 填充使用 CanvasRenderingContext2D.fill() 方法.1.2.2.1. fill 方法语法: CanvasRenderingContext2D.fill()描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色.1.2.3. 非零环绕原则填充满足非零环绕数原则说明: 在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西. 在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果. 每一个路径都是一个状态.1.2.4. 闭合路径1.2.4.1. closePath 方法语法: CanvasRenderingContext2D.closePath()描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来.举个栗子123456...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.lineTo( 300, 200 );ctx.closePath();ctx.stroke(); 结果为 1.2.5. 路径的概念 路径就是一次绘图 类比使用油漆刷墙面 首先打底色, 绝对不会一次性使用多个色彩 一定是先画完某一个色彩再考虑另一个色彩 除非需要自己创作才会考虑墙面绘画 路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域. 如果需要开启新的绘制, 那么使用 CanvasRenderingContext2D.beginPath() 方法.示例如果需要在一个区域内绘制描边的图形和填充的图形.例如1.2.6. 线型相关属性设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果 CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.lineCap 设置线末端类型. CanvasRenderingContext2D.lineJoin设置相交线的拐点. CanvasRenderingContext2D.getLineDash()获得线段样式数组. CanvasRenderingContext2D.setLineDash()设置线段样式. CanvasRenderingContext2D.lineDashOffset绘制线段偏移量.1.2.6.1. 设置线宽语法: CanvasRenderingContext2D.lineWidth = number描述: 设置线宽.例子12345678910...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineWidth = 10;ctx.moveTo( 100, 250 );ctx.lineTo( 300, 250 );ctx.stroke(); 效果 1.2.6.2. 设置线末端类型语法: CanvasRenderingContext2D.lineCap = value描述: 设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’. ‘butt’ 表示两端使用方形结束. ‘round’ 表示两端使用圆角结束. ‘square’ 表示突出的圆角结束.例子123456789101112131415...ctx.lineWidth = 10;ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'round';ctx.moveTo( 100, 130 );ctx.lineTo( 300, 130 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'square';ctx.moveTo( 100, 160 );ctx.lineTo( 300, 160 );ctx.stroke(); 效果 1.2.6.3. 设置相交线的拐点语法: CanvasRenderingContext2D.lineJoin = value描述: 设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认) ‘round’ 使用圆角连接. ‘bevel’ 使用平切连接. ‘miter’ 使用直角转.例子12345678910111213141516171819...ctx.lineWidth = 10;ctx.lineJoin = 'round';ctx.moveTo( 100, 100 );ctx.lineTo( 200, 200 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'bevel';ctx.moveTo( 100, 150 );ctx.lineTo( 200, 250 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'miter';ctx.moveTo( 100, 200 );ctx.lineTo( 200, 300 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.4. 虚线语法: CanvasRenderingContext2D.lineDashOffset = number CanvasRenderingContext2D.getLineDash() CanvasRenderingContext2D.setLineDash()描述: setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移. getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.demo12345678910111213141516171819202122232425262728...ctx.moveTo( 100, 90 );ctx.lineTo( 100, 110 );ctx.moveTo( 300, 90 );ctx.lineTo( 300, 110 );ctx.moveTo( 100, 140 );ctx.lineTo( 100, 160 );ctx.moveTo( 300, 140 );ctx.lineTo( 300, 160 );ctx.moveTo( 100, 190 );ctx.lineTo( 100, 210 );ctx.moveTo( 300, 190 );ctx.lineTo( 300, 210 );ctx.stroke();ctx.beginPath();ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.setLineDash( [ 5, 5 ] );ctx.moveTo( 100, 150 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineDashOffset = -2;ctx.moveTo( 100, 200 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.5. 填充与描边样式语法: CanvasRenderingContext2D.strokeStyle = value CanvasRenderingContext2D.fillStyle = value描述: strokeStyle 可以设置描边颜色, 与 CSS 的语法一样 fillStyle 设置填充颜色, 与 CSS 语法一样 这两个属性还可以设置渐变对象.demo123456789for (var i=0;i&lt;6;i++)&#123; for (var j=0;j&lt;6;j++)&#123; ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + Math.floor(255-42.5*j) + ')'; ctx.beginPath(); ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true); ctx.stroke(); &#125; &#125; 效果 绘制折线图(等比例缩放)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(function (w) &#123; // 创建一个构造函数 function Line(ctx,data,padding,arrow)&#123; this.ctx=ctx;// 判断,如果没有传入padding的话,那么就直接使用定义的这个数 this.padding=padding||&#123;top:10,right:10,bottom:10,left:10&#125;;// 箭头的的大小 this.arrow=arrow||&#123;width:10,height:20&#125;;// 上顶点 this.vertextTop=&#123; x:this.padding.left, y:this.padding.top &#125;// 右顶点 this.vertextRight=&#123; x:this.ctx.canvas.width-this.padding.right, y:this.ctx.canvas.height-this.padding.bottom &#125;// 原点 this.origin=&#123; x:this.padding.left, y:this.ctx.canvas.height-this.padding.bottom &#125;// 传入的数组 this.data=data;// 计算坐标轴的最大值 this.coordWidth=this.ctx.canvas.width-this.padding.left-this.padding.right; this.coordHeight=this.ctx.canvas.height-this.padding.top-this.padding.bottom; &#125;// 替换原型对象 Line.prototype=&#123;// 手动添加contructor属性 constructor:Line,// 在原型中添加方法// 将封装的方法综合到一个方法中,外面可以调用一次就可以 draw: function () &#123; this.drawVertext(); this.drawArrow(); this.drawLine(); &#125;,// 绘制坐标轴 drawVertext: function () &#123;// 在绘制前先清除路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.origin.x,this.origin.y); this.ctx.lineTo(this.vertextRight.x,this.vertextRight.y); this.ctx.stroke(); &#125;,// 绘制箭头 drawArrow:function ()&#123;// 上箭头// 绘制前先清除路径,开启新的路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.vertextTop.x-this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.lineTo(this.vertextTop.x,this.vertextTop.y+this.arrow.height/2); this.ctx.lineTo(this.vertextTop.x+this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.closePath(); this.ctx.stroke();// 右箭头 this.ctx.beginPath(); this.ctx.moveTo(this.vertextRight.x,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y-this.arrow.width/2); this.ctx.lineTo(this.vertextRight.x-this.arrow.height/2,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y+this.arrow.width/2); this.ctx.closePath(); this.ctx.stroke(); &#125;,// 绘制折线 drawLine: function () &#123; // 保存this var that =this; that.ctx.beginPath()// 计算x轴上的缩放比例 var radioX=this.coordWidth/this.data.length;// 计算y轴上的缩放比例 var radioY=this.coordHeight/Math.max.apply(null,this.data);// 通过用户传进来的数据进行绘制折线 this.data.forEach(function (val, index) &#123;// 可以根据坐标轴的原点来绘制点 that.ctx.fillRect(that.origin.x+index*radioX-5,that.origin.y-val*radioY-5,10,10); &#125;)// 绘制折线 this.data.forEach(function (val,index) &#123; that.ctx.lineTo(that.origin.x+index*radioX,that.origin.y-val*radioY); &#125;); this.ctx.stroke(); &#125; &#125;// 将window当作参数传进来,让构造函数暴露在全局变量中 w.Line=Line;&#125;(window)) 效果","tags":[]},{"title":"JavaScript-1","date":"2016-12-18T08:39:47.000Z","path":"2016/12/18/JavaScript-1/","text":"","tags":[]},{"title":"AngularJS","date":"2016-11-24T11:42:44.000Z","path":"2016/11/24/AngularJS/","text":"123&lt;div&gt; hello world&lt;/div&gt;","tags":[]}]