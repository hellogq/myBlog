[{"title":"Canvas 中级篇","date":"2016-12-18T14:12:24.000Z","path":"2016/12/18/Canvas 中级篇/","text":"2.中级篇2.1. 绘制形状绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法1.绘制矩形2.绘制圆弧 2.1.1. 绘制矩形绘制矩形的方法1.CanvasRenderingContext2D.strokeRect2.CanvasRenderingContext2D.fillRect3.CanvasRenderingContext2D.rect注意: rect方法就是矩形路径, 还需要使用 fill 或 stroke 才可以看到效果. 因此一般使用 strokeRect 或 fillRect 直接可以看到结果. 清除矩形区域CanvasRenderingContext2D.clearRect 2.1.1.1. 绘制矩形框语法: CanvasRenderingContext2D.strokeRect( x, y, width. height )描述:1.用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多.2.该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.3.使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法.4.绘制的矩形支持 strokeStyle 设置颜色样式. 案例123... ctx.strokeStyle = 'red'; ctx.strokeRect( 100, 100, 200, 100 ); 效果 2.1.1.2. 绘制填充矩形语法:CanvasRenderingContext2D.fillRect( x, y, width. height )描述:1.用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多.2.该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.3.使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法.4.绘制的矩形支持 fillStyle 设置颜色样式. 案例123...ctx.fillStyle = 'green';ctx.fillRect( 100, 100, 200, 100 ); 效果 2.1.1.3. 清除矩形区域语法:CanvasRenderingContext2D.clearRect( x, y, width, height )描述:1.用于清除画布中的矩形区域的内容.2.参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高. 案例123...ctx.fillRect( 100, 100, 200, 100 );ctx.clearRect( 110, 110, 50, 50 ); 效果","tags":[]},{"title":"Canvas 基本篇","date":"2016-12-18T13:23:34.000Z","path":"2016/12/18/Canvas 初级篇/","text":"1.基本篇1.1. 什么是Canvascanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.1canvas 英 [&apos;kænvəs] 美 [&apos;kænvəs] 帆布 画布 1.1.1.canvas 的基本用法基本语法1&lt;canvas&gt;&lt;/canvas&gt; 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.canvas 的使用领域canvas 的使用领域很多: 游戏 可视化数据(重点) banner 广告 多媒体 未来 模拟仿真 远程操作 图形编辑1.2基本绘图1.2.1. 基本绘图方法绘图步骤 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 &#39;2d&#39;. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath().01-绘制基本线1234567891011121314151617var canvas = document.createElement( 'canvas' );canvas.width = 500;canvas.height = 400;canvas.style.border = '1px dashed red';document.body.appendChild( canvas );// 获得 CanvasRenderingContext2D 对象var context = canvas.getContext( '2d' );// 设置 起点context.moveTo( 0, 0 );// 绘制直线context.lineTo( 500, 400 );// 设置 起点context.moveTo( 0, 400 );// 绘制直线context.lineTo( 500, 0 );// 描边显示效果context.stroke(); 运行结果为 1.2.1.1. 计算机直角坐标系 1.2.1.2. 代码分析 需要绘图就需要有 canvas 标签, 该标签用于展示图像. canvas 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置. 但是 canvas 只是展示图像的标签, 它没有绘图的能力. 需要使用 canvas 的上下文工具来实现绘图. 使用 canvas.getContext( &#39;2d&#39; ) 可以获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. 需要绘图, 首选设置绘图的起点. 使用 canvas 绘图, 需要主要的是他主张先描点, 再连线绘制效果. 因此需要首先设置起点, 然后在起点的基础上描述其他需要的点. 使用 CanvasRenderingContext2D.moveTo( x, y ) 方法设置起点. 其中 x, y 表示的是在坐标系中的位置. 使用 CanvasRenderingContext2D.lineTo( x, y ) 来描述绘制直线的下一个点. 依次类推可以描述多个点. 描点结束后, 需要使用CanvasRenderingContext2D.stroke() 方法来连线. 开可以显示出效果.1.2.1.3. getContext 方法语法: Canvas.getContext( typeStr )描述: 该方法用于绘制上下文工具. 如果是绘制平面图形使用 &#39;2d&#39; 作为参数, 如果绘制立体图形使用 &#39;webgl&#39;. 使用 &#39;2d&#39;返回CanvasRenderingContext2D 类型的对象. 使用 &#39;webgl&#39; 返回 WebGLRenderingContext类型的对象.1.2.1.4. moveTo 方法语法: CanvasRenderingContext2D.moveTo( x, y )描述: 该方法用于设置绘制起点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.5. lineTo 方法语法: CanvasRenderingContext2D.lineTo( x, y )描述: 该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.6. stroke 方法语法: CanvasRenderingContext2D.stroke()描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来.1.2.1.7. 结论 绘图先要获得上下文, 即绘图工具 绘图需要设置开始的坐标 绘图是先描点, 然后一个一个依次连线 依次绘图只能绘制单一样式( 色彩等 )1.2.2. 直线图形分别绘制下面的图形: 绘制直线计算坐标. 描边调用 CanvasRenderingContext2D.stroke() 方法. 填充使用 CanvasRenderingContext2D.fill() 方法.1.2.2.1. fill 方法语法: CanvasRenderingContext2D.fill()描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色.1.2.3. 非零环绕原则填充满足非零环绕数原则说明: 在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西. 在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果. 每一个路径都是一个状态.1.2.4. 闭合路径1.2.4.1. closePath 方法语法: CanvasRenderingContext2D.closePath()描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来.举个栗子123456...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.lineTo( 300, 200 );ctx.closePath();ctx.stroke(); 结果为 1.2.5. 路径的概念 路径就是一次绘图 类比使用油漆刷墙面 首先打底色, 绝对不会一次性使用多个色彩 一定是先画完某一个色彩再考虑另一个色彩 除非需要自己创作才会考虑墙面绘画 路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域. 如果需要开启新的绘制, 那么使用 CanvasRenderingContext2D.beginPath() 方法.示例如果需要在一个区域内绘制描边的图形和填充的图形.例如1.2.6. 线型相关属性设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果 CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.lineCap 设置线末端类型. CanvasRenderingContext2D.lineJoin设置相交线的拐点. CanvasRenderingContext2D.getLineDash()获得线段样式数组. CanvasRenderingContext2D.setLineDash()设置线段样式. CanvasRenderingContext2D.lineDashOffset绘制线段偏移量.1.2.6.1. 设置线宽语法: CanvasRenderingContext2D.lineWidth = number描述: 设置线宽.例子12345678910...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineWidth = 10;ctx.moveTo( 100, 250 );ctx.lineTo( 300, 250 );ctx.stroke(); 效果 1.2.6.2. 设置线末端类型语法: CanvasRenderingContext2D.lineCap = value描述: 设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’. ‘butt’ 表示两端使用方形结束. ‘round’ 表示两端使用圆角结束. ‘square’ 表示突出的圆角结束.例子123456789101112131415...ctx.lineWidth = 10;ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'round';ctx.moveTo( 100, 130 );ctx.lineTo( 300, 130 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'square';ctx.moveTo( 100, 160 );ctx.lineTo( 300, 160 );ctx.stroke(); 效果 1.2.6.3. 设置相交线的拐点语法: CanvasRenderingContext2D.lineJoin = value描述: 设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认) ‘round’ 使用圆角连接. ‘bevel’ 使用平切连接. ‘miter’ 使用直角转.例子12345678910111213141516171819...ctx.lineWidth = 10;ctx.lineJoin = 'round';ctx.moveTo( 100, 100 );ctx.lineTo( 200, 200 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'bevel';ctx.moveTo( 100, 150 );ctx.lineTo( 200, 250 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'miter';ctx.moveTo( 100, 200 );ctx.lineTo( 200, 300 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.4. 虚线语法: CanvasRenderingContext2D.lineDashOffset = number CanvasRenderingContext2D.getLineDash() CanvasRenderingContext2D.setLineDash()描述: setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移. getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.demo12345678910111213141516171819202122232425262728...ctx.moveTo( 100, 90 );ctx.lineTo( 100, 110 );ctx.moveTo( 300, 90 );ctx.lineTo( 300, 110 );ctx.moveTo( 100, 140 );ctx.lineTo( 100, 160 );ctx.moveTo( 300, 140 );ctx.lineTo( 300, 160 );ctx.moveTo( 100, 190 );ctx.lineTo( 100, 210 );ctx.moveTo( 300, 190 );ctx.lineTo( 300, 210 );ctx.stroke();ctx.beginPath();ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.setLineDash( [ 5, 5 ] );ctx.moveTo( 100, 150 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineDashOffset = -2;ctx.moveTo( 100, 200 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.5. 填充与描边样式语法: CanvasRenderingContext2D.strokeStyle = value CanvasRenderingContext2D.fillStyle = value描述: strokeStyle 可以设置描边颜色, 与 CSS 的语法一样 fillStyle 设置填充颜色, 与 CSS 语法一样 这两个属性还可以设置渐变对象.demo123456789for (var i=0;i&lt;6;i++)&#123; for (var j=0;j&lt;6;j++)&#123; ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + Math.floor(255-42.5*j) + ')'; ctx.beginPath(); ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true); ctx.stroke(); &#125; &#125; 效果 绘制折线图(等比例缩放)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(function (w) &#123; // 创建一个构造函数 function Line(ctx,data,padding,arrow)&#123; this.ctx=ctx;// 判断,如果没有传入padding的话,那么就直接使用定义的这个数 this.padding=padding||&#123;top:10,right:10,bottom:10,left:10&#125;;// 箭头的的大小 this.arrow=arrow||&#123;width:10,height:20&#125;;// 上顶点 this.vertextTop=&#123; x:this.padding.left, y:this.padding.top &#125;// 右顶点 this.vertextRight=&#123; x:this.ctx.canvas.width-this.padding.right, y:this.ctx.canvas.height-this.padding.bottom &#125;// 原点 this.origin=&#123; x:this.padding.left, y:this.ctx.canvas.height-this.padding.bottom &#125;// 传入的数组 this.data=data;// 计算坐标轴的最大值 this.coordWidth=this.ctx.canvas.width-this.padding.left-this.padding.right; this.coordHeight=this.ctx.canvas.height-this.padding.top-this.padding.bottom; &#125;// 替换原型对象 Line.prototype=&#123;// 手动添加contructor属性 constructor:Line,// 在原型中添加方法// 将封装的方法综合到一个方法中,外面可以调用一次就可以 draw: function () &#123; this.drawVertext(); this.drawArrow(); this.drawLine(); &#125;,// 绘制坐标轴 drawVertext: function () &#123;// 在绘制前先清除路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.origin.x,this.origin.y); this.ctx.lineTo(this.vertextRight.x,this.vertextRight.y); this.ctx.stroke(); &#125;,// 绘制箭头 drawArrow:function ()&#123;// 上箭头// 绘制前先清除路径,开启新的路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.vertextTop.x-this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.lineTo(this.vertextTop.x,this.vertextTop.y+this.arrow.height/2); this.ctx.lineTo(this.vertextTop.x+this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.closePath(); this.ctx.stroke();// 右箭头 this.ctx.beginPath(); this.ctx.moveTo(this.vertextRight.x,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y-this.arrow.width/2); this.ctx.lineTo(this.vertextRight.x-this.arrow.height/2,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y+this.arrow.width/2); this.ctx.closePath(); this.ctx.stroke(); &#125;,// 绘制折线 drawLine: function () &#123; // 保存this var that =this; that.ctx.beginPath()// 计算x轴上的缩放比例 var radioX=this.coordWidth/this.data.length;// 计算y轴上的缩放比例 var radioY=this.coordHeight/Math.max.apply(null,this.data);// 通过用户传进来的数据进行绘制折线 this.data.forEach(function (val, index) &#123;// 可以根据坐标轴的原点来绘制点 that.ctx.fillRect(that.origin.x+index*radioX-5,that.origin.y-val*radioY-5,10,10); &#125;)// 绘制折线 this.data.forEach(function (val,index) &#123; that.ctx.lineTo(that.origin.x+index*radioX,that.origin.y-val*radioY); &#125;); this.ctx.stroke(); &#125; &#125;// 将window当作参数传进来,让构造函数暴露在全局变量中 w.Line=Line;&#125;(window)) 效果","tags":[]},{"title":"JavaScript-1","date":"2016-12-18T08:39:47.000Z","path":"2016/12/18/JavaScript-1/","text":"","tags":[]},{"title":"AngularJS","date":"2016-11-24T11:42:44.000Z","path":"2016/11/24/AngularJS/","text":"123&lt;div&gt; hello world&lt;/div&gt;","tags":[]}]