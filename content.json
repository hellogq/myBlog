[{"title":"","date":"2016-12-18T13:17:38.115Z","path":"2016/12/18/05.Nodejs-1/","text":"模块化的思想一次开发多次使用,将代码封装起来形成一个模块 JavaScript模块化中常见的问题命名冲突(团队协作开发,不同开发人员的变量和函数名可能会相同) 文件依赖(代码重用时,引入js文件的数目可能少了或者引入的顺序不对) 模块化产生的优点 提高开发效率 代码方便重用,别人开发的模块可以直接拿过来用,不需要重复开发类似的功能 节省网络资源,提高客户响应 便于维护 维护阶段,需求变化比较频繁,使用模块化的开发方式更容易维护.模块化规范 AMD (require.js) CMD (sea.js) CommonJS (Node.js)Sea.js 一个基于CMD规范实现的模块化开发解决方案特性 简单友好的义模块定规范 自然直观的代码组织方式 seaJS推崇一个模块一个文件,遵循统一的写法基本使用 引入sea.js库 定义模块 define(function (require , exports , module){模块代码}) // require 用来获取其他模块提供的接口 // exports 是一个对象,用来向外提供模块接口.exports仅仅是module.exports的一个引用 // 不能直接给exports直接赋值 // module 是一个对象,上面存储了与当前模块相关联的属性和方法 暴露接口 exports module.exports 相当于 return(返回一个值) 扔出去的永远都是module.exports这个对象 依赖模块 require(‘模块的路径’) 以 ./ ../ 开头的相对路径 是相对于当前模块所在的位置 不以 ./ ../ 开头的路径,会相对于模块的基础路径解析（配置项中的base） 启动模块系统 // 回调函数可以省略 seajs.use(‘模块路径’); // 加载模块,模块加载完成之后执行的代码 seajs.use(‘模块路径’ , function (模块对象){业务代码}); // 一次加载多个模块的方式 seajs.use([‘模块路径’,’模块路径’ ], function (模块对象){业务代码}); exports和module.exports 功能: 通过给exports或者module.exports动态的加载变量,函数或对象,外部会获取到该接口. exports 等价于 module.exports; 可以通过多次给exports加载属性向外暴露 不能直接给exports赋值 打破作用域的封装性,让外部可以调用里面的内容 如果想暴露单个变量,函数或者对象可以通过直接给module.exports赋值即可 两者之间的区别就是一个不能直接赋值,一个能直接赋值 模块配置base添加规则完整的绝对路径 不会加base以 “.” 开头 会相对于当前（被调用的）模块解析地址。 如果不存在被调用的模块（如seajs.use() ）， 则会相对于当前页面解析地址。以 “/“ 开头 相对于当前页面的根目录 解析地址普通命名 直接加上base前缀base值base 默认值是 seajs所在目录seajs.config()中base的解析与ID命名解析规则相同","tags":[]},{"title":"","date":"2016-12-18T13:17:38.113Z","path":"2016/12/18/04.流行框架--AngularJS01/","text":"AngluarJS","tags":[]},{"title":"","date":"2016-12-18T13:17:38.090Z","path":"2016/12/18/03.流行框架--Git02/","text":"3.1.3 Git分支值得注意的是所有的提交实际上都是在分支的基础上进行的 ‘HEAD’ 指针,用来表明当前处于哪个分支的哪个版本 我们在初始化仓库的时候(实际上是产生第一次提交的时候)Git会默认帮我们创建一个master的分支,并且有指针指向了末端1.创建分支 git branch 分支名称 新的分支会在当前分支原有的历史版本的节点上进行创建—-子分支 新创建的子分支会继承父分支的所有提交历史2.获取分支 git branch3.切换分支 git checkout 分支名称4.再次提交操作 修改bug之后提交(git add… git commit -m …) 这次的提交历史版本就会记录在新的分支上,并且HEAD伴随新分支在移动5.合并分支 git merge 分支名称 例如 指针指在cart这个分支上,git merge master 是将master合并到了cart上6.删除分支 git branch -d/D 分支名称 -D是强制删除 删除的文件是本地的,传到服务器上的并没有被删除7.创建并切换到分支 git checkout -b newbranch3.1.4 Git远程(共享)仓库创建共享仓库 登陆远程服务器,在里面操作 Git要求共享仓库是一个以 .git结尾的目录 mkdir repo.git cd repo.git(进入这个目录) 初始化这个共享仓库,也叫裸仓库 git init –bare 这是这个仓库是一个空的仓库,并且不允许在这个仓库中进行任何修改向共享仓库共享内容 git push 共享仓库的地址 上传的分支名称从共享仓库里取出内容 1.新创建一个目录(模拟另外一个开发者) 2.git clone(克隆) 共享仓库地址 文件名 3.git pull 共享仓库地址 文件名其他 git remote show itcast 查看itcast这个远程主机真正的地址 git push origin hotfix:hotfix 创建的远程的分支为hotfix git push origin hotfix ===&gt;git push origin hotfix:master git remote add “主机名称” “远程仓库地址”添加远程主机，即给远程主机起个别名，方便使用 git remote 可以查看已添加的远程主3.1.5 如何生成密钥 ssh-keygen -t rsa 一路回车3.1.6 GitLab分支的管理 不要有太多的树杈（子分支） 要有一个“稳定分支”，即master分支不要轻意被修改 要有一个开发分支（developer），保证master分支的稳定性 所有的功能分支（feature）从developer创建 所有功能开发完成后新建发布分支（release）","tags":[]},{"title":"","date":"2016-12-18T13:17:38.037Z","path":"2016/12/18/03.流行框架--Git01/","text":"Git1.1 Shell和vi1.1.1 什么shellshell就是壳(通过操作壳---&gt;操作核心---&gt;驱动硬件) shell的分类 图形界面shell—&gt;桌面图标—&gt;通过提供友好的可视化界面,调用相应应用程序 命令行shell—&gt;命令行—&gt;通过键盘输入特定命令的方式,调用相应的应用程序window系统中的shell cmd WindowPowerShellLinux系统中的shell Boume Shell(sh) Boume Again Shell(bash)1.1.2 认识bash这个shell bash这个软件模拟集成了bash大部分命令 各个shell的功能差不多,Linux默认使用bush1.1.3 bash中的命令bash命令格式 命令 [-options] [参数] 查看bash命令的帮助 : 命令 –helpbash常见命令 pwd (Print Working Directory) 查看当前目录 cd (Change Directory) 切换目录 $cd ../ 返回上一级 $cd bush 进入bush这个目录文件夹 ls (List) 查看当前目录下的内容 $ ls 4-code(查看某个目录下的内容) $ ls -a (a:all) 查看当前目录下所有的内容 $ ls l 以列表的形式展示内容(文件名,日期,文件大小等) $ ls -a -l (简写:$ ls -al) 查看当前目录下的所有的内容以列表的形式展示出来 mkdir (Make Directory) 创建目录 $ mkdir css 创建一个名为css的文件夹 一次创建多个文件夹 文件夹名字中间用空格隔开 $ mkdir css js images touch 创建文件 $ touch index.html 创建相应的文件 $ touch js/index.js 后面跟的是路径,表示在某个文件夹中创建了一个文件 cat 查看文件全部内容 如: $ cat images more/less 查看文件 more 没有集成好,在window中不能用 less 查看文件中的内容 空格 分页查看 回车 每次查看一行 rm (remove) 删除文件 不能删除文件夹 $ rm index.html $ rm -rf 可以删除非空目录 -rf 表示递归强制删除 rmdir (Remove Directory) 删除文件夹 只能删除空文件夹 不常用 mv (move) 移动文件或重命名 $ mv index.html image 将index这个文件移动到image这个文件夹中 $ mv index.html image/aaa.html 在剪切过程中重命名 cp (copy) 复制文件 $ cp index.html css 将index文件复制到css文件夹中 head 查看文件前几行 $ head -n 5 index.html 查看index文件的前五行 简写 $ head -5 index.html tail 查看文件后几行 $ tail -f -n 5 index.html 查看index文件的后5行内容 tab 自动补全 连按连按两次会将所有匹配内容显示出来. history 查看操作历史 &gt; / &gt;&gt; 重定向 &gt; 覆盖 $ echo hello &gt; index.html 输出的hello会将index文件中的内容全部覆盖 &gt;&gt; 追加 $ echo hello &gt;&gt; index.html 输出的hello会加到index文件的内容中 wget 下载 tar 解压缩 不能解压.rar .zip格式的 curt 网络请求 例如: $ curl http://www.baidu.com whoami 查看当前用户 | 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数 grep 匹配内容，一般结合管道符使用1.1.4 vi编辑器什么是vi编辑器 如同Windows下的记事本，vi编辑器是Linux下的标配，通过它我们可以创建、编辑文件。它是一个随系统一起安装的文本编辑软件。vi编辑器的三种模式 命令模式 插入模式 底行模式三种模式的切换 使用vi编辑器 打开/创建文件， vi 文件路径 底行模式 底行模式 : w保存，:w filenme另存为 底行模式 : q退出 底行模式 : wq保存并退出 底行模式 : e! 撤销更改，返回到上一次保存的状态 底行模式 : q! 不保存强制退出 底行模式 : set nu 设置行号 命令模式 命令模式 : ZZ（大写）保存并退出 命令模式 : u辙销操作，可多次使用 命令模式 : dd删除当前行 命令模式 : yy复制当前行 命令模式 : p 粘贴内容 命令模式 : ctrl+f向前翻页 命令模式 : ctrl+b向后翻页 命令模式 : i进入编辑模式，当前光标处插入 命令模式 : a进入编辑模式，当前光标后插入 命令模式 : A进入编辑模式，光标移动到行尾 命令模式 : o进入编辑模式，当前行下面插入新行 命令模式 : O进入编辑模式，当前行上面插入新行1.1.5 SSHSSH是一种网络协议,用于计算机之间的加密登陆SSH知识一种协议,存在多种实现,OpenSSH–他是自由软件,应用非常广泛常见加密技术 对称性加密 对称加密算法在加密和解密时使用的是同一个密钥 非对称性加密(SSH使用的是非对称性加密) 而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥分别是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。登陆远程电脑 登陆 $ ssh 用户名@IP地址 如果是首次登陆,那么会在本地保存一个公钥,输入yes 输入密码 进行操作(输入bash命令) 操作完成之后退出(exit)2.1 版本控制 版本控制（Version Control Systems）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统 这个系统可以自动帮我们备份文件的每一次更改，并且可以非常方便的恢复到任意的备份（版本）状态 分类 本地版本控制系统 这种类型的版本控制系统,功能比较单一 很难实现对人协同开发 保存在本地 集中式版本控制系统 通过客户端上传到服务器 其代表是SVN 如果服务器出现鼓掌,将会导致数据(版本)丢失,严重依赖网络 分布式版本控制系统 不需要中央服务器，每个协同开发者都拥有一个完整的版本库 代表是Git 3.1了解Git多人开发,共享文件,共享代码 版本控制工具(版本控制工具有很多,比如:SVN) 3.1.1 Git工作原理Git的三种状态 已提交 commotiied 已修改 modified 已暂存 staged工作区域概念 Git仓库 是Git用来保存项目的元数据和对象数据库的地方 工作目录 是对项目的某个版本独立提取出来的内容 暂存区域 是一个文件,保存了下一次将提交的文件列表信息 一般说法叫暂存区域Git基本工作流程 在工作目录中修改文件 暂存文件,将文件的快照放入暂存区域 提交文件,找到暂存区域的文件,将快照永久性存储到Git仓库目录3.1.2 Git基础配置用户 $ git config –global user.name”自己的名字” $ git config –global user.email”自己的邮箱地址” 配置用户只需要执行一次,可以重复使用初始化仓库 $ git init git init 只是创建了一个名为.git的隐藏目录,这就存储我们历史版本的仓库 $ ls -al 可以查看查看文件状态 $ git status git会忽略空白的目录添加文件到暂存区 $ git add 文件名 -A或者是 * 代表所有 放到暂存区的文件被标记成了绿色，等待提交。撤销更改 $ git checkout 文件名 将暂存区的内容还原到工作区提交文件 $ git commit -m ‘备注信息’ -m一定不能省去 将暂存区被标记成绿色的文件，全部提交到本地仓库存储 并且生成一个新版本/存盘点查看提交历史 $ git log 查看当前版本/历史/存盘点恢复上一次提交的状态 $ git reset –herd SHA值","tags":[]},{"title":"","date":"2016-12-18T13:17:38.035Z","path":"2016/12/18/02.封装轻量级的jQuery-2/","text":"jQuery中的ajax","tags":[]},{"title":"","date":"2016-12-18T13:17:37.751Z","path":"2016/12/18/02.封装轻量级的jQuery-1/","text":"onreadystatechange事件 onreadystatechange事件是微软对IE浏览器的私有事件阔重重,所有元素都存在onreadystatechange事件 下列元素对象够可以触发此事件,因为他们均会加载数据:applet/document/frame/frameset/ iframe/img/link/object/script和xml元素.其他元素对象仅当DHTMLBehavior被追加后回出发onreadystatechange事件 DOMContentLoaded事件这个事件是H5新增的,兼容IE9会在DOM解析完成之后触发,这个事件要比onload事件快很多,但是也会有例外.如果发生了例外,DOMContentLoaded事件和onload事件触发的时间间隔相差不会很大所以可以认为DOMContentLoaded事件比onload事件快,只监听DOMContentLoaded事件即可","tags":[]},{"title":"","date":"2016-12-18T13:17:37.748Z","path":"2016/12/18/01.Canvas-2/","text":"2.中级篇2.1. 绘制形状绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法 绘制矩形 绘制圆弧2.1.1. 绘制矩形","tags":[]},{"title":"","date":"2016-12-18T13:17:37.745Z","path":"2016/12/18/01.Canvas-1/","text":"1.基本篇1.1. 什么是Canvascanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.1canvas 英 [&apos;kænvəs] 美 [&apos;kænvəs] 帆布 画布 1.1.1.canvas 的基本用法基本语法1&lt;canvas&gt;&lt;/canvas&gt; 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api. canvas 的使用领域canvas 的使用领域很多: 游戏 可视化数据(重点) banner 广告 多媒体 未来 模拟仿真 远程操作 图形编辑1.2基本绘图1.2.1. 基本绘图方法绘图步骤 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 &#39;2d&#39;. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath().01-绘制基本线123456789101112131415161718192021222324252627var canvas = document.createElement( 'canvas' );canvas.width = 500;canvas.height = 400;canvas.style.border = '1px dashed red';document.body.appendChild( canvas );// 获得 CanvasRenderingContext2D 对象var context = canvas.getContext( '2d' );// 设置 起点context.moveTo( 0, 0 );// 绘制直线context.lineTo( 500, 400 );// 设置 起点context.moveTo( 0, 400 );// 绘制直线context.lineTo( 500, 0 );// 描边显示效果context.stroke(); 运行结果为 1.2.1.1. 计算机直角坐标系 1.2.1.2. 代码分析 需要绘图就需要有 canvas 标签, 该标签用于展示图像. canvas 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置. 但是 canvas 只是展示图像的标签, 它没有绘图的能力. 需要使用 canvas 的上下文工具来实现绘图. 使用 canvas.getContext( &#39;2d&#39; ) 可以获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. 需要绘图, 首选设置绘图的起点. 使用 canvas 绘图, 需要主要的是他主张先描点, 再连线绘制效果. 因此需要首先设置起点, 然后在起点的基础上描述其他需要的点. 使用 CanvasRenderingContext2D.moveTo( x, y ) 方法设置起点. 其中 x, y 表示的是在坐标系中的位置. 使用 CanvasRenderingContext2D.lineTo( x, y ) 来描述绘制直线的下一个点. 依次类推可以描述多个点. 描点结束后, 需要使用CanvasRenderingContext2D.stroke() 方法来连线. 开可以显示出效果.1.2.1.3. getContext 方法语法: Canvas.getContext( typeStr ) 描述: 该方法用于绘制上下文工具. 如果是绘制平面图形使用 &#39;2d&#39; 作为参数, 如果绘制立体图形使用 &#39;webgl&#39;. 使用 &#39;2d&#39;返回CanvasRenderingContext2D 类型的对象. 使用 &#39;webgl&#39; 返回 WebGLRenderingContext类型的对象.1.2.1.4. moveTo 方法语法: CanvasRenderingContext2D.moveTo( x, y ) 描述: 该方法用于设置绘制起点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.5. lineTo 方法语法: CanvasRenderingContext2D.lineTo( x, y ) 描述: 该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.1.2.1.6. stroke 方法语法: CanvasRenderingContext2D.stroke() 描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来. 1.2.1.7. 结论 绘图先要获得上下文, 即绘图工具 绘图需要设置开始的坐标 绘图是先描点, 然后一个一个依次连线 依次绘图只能绘制单一样式( 色彩等 )1.2.2. 直线图形 分别绘制下面的图形: 绘制直线计算坐标. 描边调用 CanvasRenderingContext2D.stroke() 方法. 填充使用 CanvasRenderingContext2D.fill() 方法.1.2.2.1. fill 方法语法: CanvasRenderingContext2D.fill() 描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色. 1.2.3. 非零环绕原则填充满足非零环绕数原则说明: 在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西. 在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果. 每一个路径都是一个状态.1.2.4. 闭合路径1.2.4.1. closePath 方法 语法: CanvasRenderingContext2D.closePath() 描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来. 举个栗子123456...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.lineTo( 300, 200 );ctx.closePath();ctx.stroke(); 结果为 1.2.5. 路径的概念 路径就是一次绘图 类比使用油漆刷墙面 首先打底色, 绝对不会一次性使用多个色彩 一定是先画完某一个色彩再考虑另一个色彩 除非需要自己创作才会考虑墙面绘画 路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域. 如果需要开启新的绘制, 那么使用 CanvasRenderingContext2D.beginPath() 方法.示例 如果需要在一个区域内绘制描边的图形和填充的图形.例如 1.2.6. 线型相关属性设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果 CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.lineCap 设置线末端类型. CanvasRenderingContext2D.lineJoin设置相交线的拐点. CanvasRenderingContext2D.getLineDash()获得线段样式数组. CanvasRenderingContext2D.setLineDash()设置线段样式. CanvasRenderingContext2D.lineDashOffset绘制线段偏移量.1.2.6.1. 设置线宽 语法: CanvasRenderingContext2D.lineWidth = number 描述: 设置线宽. 例子12345678910...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineWidth = 10;ctx.moveTo( 100, 250 );ctx.lineTo( 300, 250 );ctx.stroke(); 效果 1.2.6.2. 设置线末端类型语法: CanvasRenderingContext2D.lineCap = value 描述: 设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’. ‘butt’ 表示两端使用方形结束. ‘round’ 表示两端使用圆角结束. ‘square’ 表示突出的圆角结束.例子123456789101112131415161718...ctx.lineWidth = 10;ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'round';ctx.moveTo( 100, 130 );ctx.lineTo( 300, 130 );ctx.stroke();ctx.beginPath();ctx.lineCap = 'square';ctx.moveTo( 100, 160 );ctx.lineTo( 300, 160 );ctx.stroke(); 效果 1.2.6.3. 设置相交线的拐点语法: CanvasRenderingContext2D.lineJoin = value 描述: 设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认) ‘round’ 使用圆角连接. ‘bevel’ 使用平切连接. ‘miter’ 使用直角转.例子123456789101112131415161718192021...ctx.lineWidth = 10;ctx.lineJoin = 'round';ctx.moveTo( 100, 100 );ctx.lineTo( 200, 200 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'bevel';ctx.moveTo( 100, 150 );ctx.lineTo( 200, 250 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineJoin = 'miter';ctx.moveTo( 100, 200 );ctx.lineTo( 200, 300 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.4. 虚线语法: CanvasRenderingContext2D.lineDashOffset = number CanvasRenderingContext2D.getLineDash() CanvasRenderingContext2D.setLineDash() 描述: setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移. getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.demo123456789101112131415161718192021222324252627282930313233...ctx.moveTo( 100, 90 );ctx.lineTo( 100, 110 );ctx.moveTo( 300, 90 );ctx.lineTo( 300, 110 );ctx.moveTo( 100, 140 );ctx.lineTo( 100, 160 );ctx.moveTo( 300, 140 );ctx.lineTo( 300, 160 );ctx.moveTo( 100, 190 );ctx.lineTo( 100, 210 );ctx.moveTo( 300, 190 );ctx.lineTo( 300, 210 );ctx.stroke();ctx.beginPath();ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.stroke();ctx.beginPath();ctx.setLineDash( [ 5, 5 ] );ctx.moveTo( 100, 150 );ctx.lineTo( 300, 150 );ctx.stroke();ctx.beginPath();ctx.lineDashOffset = -2;ctx.moveTo( 100, 200 );ctx.lineTo( 300, 200 );ctx.stroke(); 效果 1.2.6.5. 填充与描边样式语法: CanvasRenderingContext2D.strokeStyle = value CanvasRenderingContext2D.fillStyle = value描述: strokeStyle 可以设置描边颜色, 与 CSS 的语法一样 fillStyle 设置填充颜色, 与 CSS 语法一样 这两个属性还可以设置渐变对象.demo123456789for (var i=0;i&lt;6;i++)&#123; for (var j=0;j&lt;6;j++)&#123; ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + Math.floor(255-42.5*j) + ')'; ctx.beginPath(); ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true); ctx.stroke(); &#125; &#125; 效果 绘制折线图(等比例缩放)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(function (w) &#123; // 创建一个构造函数 function Line(ctx,data,padding,arrow)&#123; this.ctx=ctx;// 判断,如果没有传入padding的话,那么就直接使用定义的这个数 this.padding=padding||&#123;top:10,right:10,bottom:10,left:10&#125;;// 箭头的的大小 this.arrow=arrow||&#123;width:10,height:20&#125;;// 上顶点 this.vertextTop=&#123; x:this.padding.left, y:this.padding.top &#125;// 右顶点 this.vertextRight=&#123; x:this.ctx.canvas.width-this.padding.right, y:this.ctx.canvas.height-this.padding.bottom &#125;// 原点 this.origin=&#123; x:this.padding.left, y:this.ctx.canvas.height-this.padding.bottom &#125;// 传入的数组 this.data=data;// 计算坐标轴的最大值 this.coordWidth=this.ctx.canvas.width-this.padding.left-this.padding.right; this.coordHeight=this.ctx.canvas.height-this.padding.top-this.padding.bottom; &#125;// 替换原型对象 Line.prototype=&#123;// 手动添加contructor属性 constructor:Line,// 在原型中添加方法// 将封装的方法综合到一个方法中,外面可以调用一次就可以 draw: function () &#123; this.drawVertext(); this.drawArrow(); this.drawLine(); &#125;,// 绘制坐标轴 drawVertext: function () &#123;// 在绘制前先清除路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.origin.x,this.origin.y); this.ctx.lineTo(this.vertextRight.x,this.vertextRight.y); this.ctx.stroke(); &#125;,// 绘制箭头 drawArrow:function ()&#123;// 上箭头// 绘制前先清除路径,开启新的路径 this.ctx.beginPath(); this.ctx.moveTo(this.vertextTop.x,this.vertextTop.y); this.ctx.lineTo(this.vertextTop.x-this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.lineTo(this.vertextTop.x,this.vertextTop.y+this.arrow.height/2); this.ctx.lineTo(this.vertextTop.x+this.arrow.width/2,this.vertextTop.y+this.arrow.height); this.ctx.closePath(); this.ctx.stroke();// 右箭头 this.ctx.beginPath(); this.ctx.moveTo(this.vertextRight.x,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y-this.arrow.width/2); this.ctx.lineTo(this.vertextRight.x-this.arrow.height/2,this.vertextRight.y); this.ctx.lineTo(this.vertextRight.x-this.arrow.height,this.vertextRight.y+this.arrow.width/2); this.ctx.closePath(); this.ctx.stroke(); &#125;,// 绘制折线 drawLine: function () &#123; // 保存this var that =this; that.ctx.beginPath()// 计算x轴上的缩放比例 var radioX=this.coordWidth/this.data.length;// 计算y轴上的缩放比例 var radioY=this.coordHeight/Math.max.apply(null,this.data);// 通过用户传进来的数据进行绘制折线 this.data.forEach(function (val, index) &#123;// 可以根据坐标轴的原点来绘制点 that.ctx.fillRect(that.origin.x+index*radioX-5,that.origin.y-val*radioY-5,10,10); &#125;)// 绘制折线 this.data.forEach(function (val,index) &#123; that.ctx.lineTo(that.origin.x+index*radioX,that.origin.y-val*radioY); &#125;); this.ctx.stroke(); &#125; &#125;// 将window当作参数传进来,让构造函数暴露在全局变量中 w.Line=Line;&#125;(window)) 效果","tags":[]},{"title":"","date":"2016-12-18T13:17:37.545Z","path":"2016/12/18/05.Nodejs-2/","text":"Nodejs介绍nodejs是基于jsnode.js和JavaScript的关系?node.js的特点和好处cmd命令 清楚屏幕上的内容 cls通过在REPL交互式运行环境不写var 不能确定定义的这个变量到底是干什么的…赋值还是定义的全局变量全局变量:global.a=123 和 a=123 的定义是一直的console.assert(foo==1,’失败’) 断言(用来测试的)console.time()和console.timeEnd()是成对出现的console.log(dirname)输出当前文件所在的路径console.log(filename)输出当前文件的全路径 require缓存的是module对象 当执行npm install 的时候,他会自动跑到npm的网站,然后找到该npm -g install + 包名 全局安装npm在安装的时候,在全局设置了一个安装全局的目录install的包安装到npm的去全局目录中安装的包有两种类型:安装到全局的(安装命令行工具) 不安装到全局的(工具包)npm docs + 包名 例如: npm docs jquery 打开jquery的文档 链接的地址是自己在写包的时候添加的npm install –save 生产环境简写:npm install -save-dev 开发环境简写: npm i -D jquery@3. (jquery@3. 下载指定的包,@后面的是版本号)npm config set prefix 修改全局安装目录 (不建议使用,容易手抖改错)建议到文件夹里修改(C:\\users\\用户名 里面有一个.npmrc的文件 改prefix=自己的路径 去全局的环境修改path)name: 包名要与外面的文件夹名字一致(不一致也可以,但是容易出现错误)关键词:通过搜索关键词来找到相应的包,并且下载下来repository: 包所在的位置license: 是否开源 MIT(开源)包名是唯一的 当函数体有一个参数有返回值的时候 var foo=function(v){ return v;}var foo=v=&gt;v;当函数体没有参数有返回值的时候 var foo=function(){ return v;} var foo=()=&gt;v;当函数体有多个参数有返回值的时候 var foo=function(v1,v2){ return v1+v2;}var foo=(v1,v2)=&gt;v1+v2;当函数体有多个参数没有返回值的时候var foo=function(v1,v2){ console.log(v1); console.log(v2); }var foo=(v1,v2)=&gt;{ console.log(v1); console.log(v2); }; mvvm m model v view vm view-model (也就是$scop)mvc 模型 链接数据库的 视图 展示 控制器 写主要逻辑的双向数据绑定监听angular核心机制 脏检查 (非常重要)","tags":[]},{"title":"JavaScript-1","date":"2016-12-18T08:39:47.000Z","path":"2016/12/18/JavaScript-1/","text":"","tags":[]},{"title":"AngularJS","date":"2016-11-24T11:42:44.000Z","path":"2016/11/24/AngularJS/","text":"123&lt;div&gt; hello world&lt;/div&gt;","tags":[]}]